- [1.2 选择排序 | 菜鸟教程](https://www.runoob.com/w3cnote/selection-sort.html)
- [11.2   选择排序 - Hello 算法](https://www.hello-algo.com/chapter_sorting/selection_sort/)

# 一、思想

### 1.1 基本思想

- 开启循环，每次循环从未排序数据区间选择最小元素并将其放到已排序数据区间末尾
- 个人理解：从左到右，每次循环在未排序数据区间找到最小元素并放到已排序区间末尾直至将所有未排序数据区间清空，从而完成元素排序
- 动图演示：
  ![](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)

### 1.2 算法步骤

- 首先初始状态下，所有元素未排序(即未排序区间为$[0,n-1]$)
- 找到区间$[0,n-1]$的最小元素并与位置 0 处的元素交换；完成后，第一个元素已完成排序
- 找到区间$[1,n-1]$的最小元素并与位置 1 处的元素交换；完成后，第二个元素已完成排序
- 依此类推，经过$n-1$轮选择与交换后，前$n-1$个元素已完成排序，最后剩下的元素必定是最大元素，无需排序，采用选择排序算法的元素排序完成

# 二、核心代码

```cpp
// v为待排序数组
// n为待排序数组长度
// k为每次循环中最小元素的索引
for (int i = 0; i < n - 1; i++)
{
	int k = i;
	for (int j = i + 1; j < n; j++)
	{
		if (v[j] < v[k])
		{
			k = j;
		}
	}
	// 交换元素
	int temp = v[i];
	v[i] = v[k];
	v[k] = temp;
}
```

# 三、算法性能

### 3.1 性能

- 时间复杂度始终为 $O(n^2)$ --> 非自适应排序
- 空间复杂度 $O(1)$ ：指针 i 和 j 使用常数大小的额外空间
- 原地排序(见[原地算法](../原地算法.md))
- 非稳定排序：选择排序过程中相等元素的相对顺序可能会发生改变(例如：5 7 5 10 2 9)

### 3.2 算法优化

暂无
