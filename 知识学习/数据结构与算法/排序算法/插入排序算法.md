- [1.3 插入排序 | 菜鸟教程](https://www.runoob.com/w3cnote/insertion-sort.html)
- [11.4   插入排序 - Hello 算法](https://www.hello-algo.com/chapter_sorting/insertion_sort/)

# 一、思想

### 1.1 基本思想

- 构建有序序列，对于未排序序列数据，在已排序序列中从后向前找到合适的位置插入
- 个人理解：将待排序数据按照大小关系放到已排序序列中的合适位置
- 动图演示：
  ![](https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif)

### 1.2 算法步骤

- 首先默认待排序序列第一个元素已完成排序
- 选取第二个元素，与已排序序列从后往前进行对比，若已排序序列数据大于选取的第二个元素则往后移，否则插入对应的正确位置，此时已有两个元素完成排序
- 以此类推，最后一次循环中选取最后一个元素插入到已排序序列的正确位置，此时所有元素已完成排序

# 二、核心代码

```cpp
// v为待排序数组
// n为待排序数组长度
// temp为待插入数据
// j范围为[0,i-1]
for (int i = 1; i < n; i++)
{
	int temp = v[i];
	int j = i - 1;
	while (j >= 0 && v[j] > temp)
	{
		// v[j]元素后移一位
		v[j + 1] = v[j];
		j--;
	}
	// 将v[i]插入正确的位置
	v[j + 1] = temp;
}
```

# 三、算法性能

### 3.1 性能

- 时间复杂度为 $O(n^2)$ --> 自适应排序 -> 待排序序列完全有序时，时间复杂度最佳为$O(n)$
- 空间复杂度 $O(1)$ ：指针 i 和 j 使用常数大小的额外空间
- 原地排序(见[原地算法](../原地算法.md))
- 稳定排序：插入过程中将元素插入相等元素右边，不改变它们的相对位置

### 3.2 算法优势

> 数据量较小情况下，插入排序通常更快(相对于快速排序算法：时间复杂度为$O(n*logn$))
> 冒泡/选择/插入排序算法时间复杂度都为$O(n^2)$，但实际情况中插入排序算法使用频率显著**更高**
