# Boyer-Moore(BM)算法

参考：
[字符串匹配的 Boyer-Moore 算法 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html)
[BM 算法精讲-CSDN 博客](https://blog.csdn.net/cygodwg/article/details/100089993)
[BM 算法的 C/C++代码实现-CSDN 博客](https://blog.csdn.net/aruewds/article/details/115254348)

![](https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050302.png)

### BM 算法原理

- 首先，字符串与搜索词的头部对齐，从尾部开始比较(若尾部不匹配，那么对应子字符串一定不匹配)，这里 S 与 E 不匹配，因此 S 被称为"坏字符"，也即不匹配的字符
  ![](https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050303.png)
- 由于上面的 S 不在搜索词中，因此可以直接把搜索词与字符串中 S 的后一位进行对齐，然后依旧从尾部开始比较，发现 P 与 E 不匹配，P 也是"坏字符"，但发现 P 在搜索词中，因此将搜索词后移两位，使两个 P 对齐
  ![](https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050304.png)
  ![](https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050305.png)
- 由此可以得出"坏字符规则"，搜索词每次`后移位数=坏字符对应搜索词的位置-该坏字符在搜索词中上一次出现的位置`，若坏字符不在搜索词中，则该坏字符在搜索词中上一次出现位置为-1
- 继续比较，直到 I 与 A 不匹配，但是 MPLE 匹配，此时 MPLE 称为"好后缀"(E/LE/PLE/MPLE 也称为"好后缀")，此时可以按照坏字符规则往后移动，但是存在好后缀，因此可以采用"好后缀规则"，即搜索词`后移位数=好后缀位置-好后缀在搜索词中上一次出现的位置(该位置去好后缀的最后一个字符的位置)`，若好后缀在搜索词中只出现一次，则好后缀在搜索词中上一次出现位置为-1，若有多个好后缀，除最长的好后缀之外，其他好后缀上一次出现位置必须是头部；此时，在所有好后缀 E/LE/PLE/MPLE 中，只有 E 在搜索词中出现在头部，所以后移 6-0=6 位，而采用坏字符规则只能后移 3 位，因此 BM 算法基本思想是每次后移值是这两个规则中的较大值
  ![](https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050309.png)
  ![](https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050312.png)
- 更巧妙的是，这两个规则的移动位数，只与搜索词有关，与原字符串无关。因此，可以预先计算生成《坏字符规则表》和《好后缀规则表》。使用时，只要查表比较一下就可以了
  ![](https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050313.png)
  ![](https://www.ruanyifeng.com/blogimg/asset/201305/bg2013050314.png)
- 从尾部开始逐位比较，发现全部匹配，于是搜索结束。如果还要继续查找（即找出全部匹配），则根据"好后缀规则"，后移 6 - 0 = 6 位，即头部的 E 移到尾部的 E 的位置

### BM 算法 C++实现

BM 算法主要分为两个部分：预处理和匹配。预处理阶段的目的是计算模式串中每个字符在模式串中最右边出现的位置，以此来确定匹配时应该移动的距离。匹配阶段则是从文本串的末尾开始匹配，根据预处理阶段得到的跳跃表来决定下一步应该移动的距离

```c++
#include <string>
#include <iostream>
using namespace std;

#define ASIZE 256 // ASCII字母的种类

// 1.坏后缀数组建立，类似于字典（map），用于判断坏字符在pattern中的位置
void generateBC(string str, int bc[])
{
    for (int i = 0; i < ASIZE; i++)
        bc[i] = -1;

    for (int i = 0; i < str.size(); i++)
        bc[str[i]] = i;
}

// 2.好后缀数组的建立,suffix为后缀字符对应前面的位置，prefix存储：是否存在匹配的前缀字串
void generateGS(string str, int suffix[], bool prefix[])
{
    int n = str.size();
    for (int i = 0; i < n - 1; i++)
    {
        suffix[i] = -1;
        prefix[i] = false;
    }

    for (int i = 0; i < n - 1; i++)
    {
        int j = i;                                 // 从第一个字符开始遍历，str[j]
        int k = 0;                                 // 最后一个字符的变化，对应下面的str[n - 1 - k]
        while (j >= 0 && str[j] == str[n - 1 - k]) // 和最后一个字符对比，相等则倒数第二个
        {
            j--;
            k++;
            suffix[k] = j + 1; // 如果k=1，则是一个字符长度的后缀对应匹配位置的值
        }
        if (j == -1) // 说明有前缀字符对应
            prefix[k] = true;
    }
}

// 3.返回好后缀移动的次数,index为坏字符位置-其后面就是好后缀，size为str大小
int getGsMove(int suffix[], bool prefix[], int index, int size)
{
    int len = size - index - 1;         // 好字符的长度，因为index为坏字符位置，所以要多减1
    if (suffix[len] != -1)              // 当前len长度的后缀坏字符串前边有匹配的字符
        return index + 1 - suffix[len]; // 后移位数 = 好后缀的位置(index + 1) - 搜索词中的上一次出现位置

    // index为坏字符，index+1为好后缀，index+2为子好后缀
    for (int i = index + 2; i < size; i++)
    {
        if (prefix[size - i]) // 因为prefix从1开始
            return i;         // 移动当前位置离前缀位置，acba-对应a移动3
    }

    return 0;
}

// 4.返回找到匹配字符串的头(从0开始索引,匹配到第一个字符串就停止)，否则返回-1
int BM(string str, string pattern)
{
    int n = str.size();
    int m = pattern.size();
    int bc[ASIZE]; // 坏字符数组
    int *suffix = (int *)malloc(sizeof(int) * m);
    bool *prefix = (bool *)malloc(sizeof(bool) * m);

    generateBC(pattern, bc);
    generateGS(pattern, suffix, prefix);

    int i = 0;
    while (i <= n - m)
    {
        int j = 0;
        for (j = m - 1; j >= 0; j--)
        {
            if (pattern[j] != str[i + j]) // 从后往前匹配str和pattern
                break;
        }
        if (j < 0) // 匹配结束
            return i;
        else
        {
            int numBc = j - bc[str[i + j]]; // bc移动的位数
            int numGs = 0;
            if (j < m - 1) // 最后一个字符就是坏字符，无需判断好字符
            {
                numGs = getGsMove(suffix, prefix, j, m); // Gs移动的位数
            }
            i += numBc > numGs ? numBc : numGs;
        }
    }

    return -1;
}

int main()
{
    cout << BM("HERE IS A SIMPLE EXAMPLE", "EXAMPLE") << endl;
}
```
