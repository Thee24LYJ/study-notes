- [一文搞懂 TCP 与 UDP 的区别 - 羊大葱 - 博客园](https://www.cnblogs.com/lishanyang/p/14889858.html)
- [TCP 和 UDP 详解(非常详细)-CSDN 博客](https://blog.csdn.net/hansionz/article/details/86435127)
- [计算机网络-TCP 和 UDP 总结（区别、优缺点、应用场景） - 秦羽的思考 - 博客园](https://www.cnblogs.com/xuwc/p/14023038.html)
- [Introduction | 理解 TCP 和 UDP](https://jerryc8080.gitbook.io/understand-tcp-and-udp)
- [计算机网络——TCP 的三次握手与四次挥手（超详细） - 特务依昂 - 博客园](https://www.cnblogs.com/tuyang1129/p/12435772.html)
- [整理了一些容易遗忘的网络知识](https://mp.weixin.qq.com/s/dASphKuVL1DhB9-Lhrc89g)
- [TCP 三次握手和四次挥手，中间失败了会发生什么？](https://zhuanlan.zhihu.com/p/557759425)
- [什么是 TCP 滑动窗口？（解释+流程示例）](https://blog.csdn.net/qq_46631497/article/details/137253124)
- [三次握手、四次挥手 \| 爱编程的大丙](https://subingwen.cn/linux/three-four/)
- [TCP 状态转换 \| 爱编程的大丙](https://subingwen.cn/linux/tcp-status/)

# 一、计算机网络体系结构

### 1.1 三种计算机网络体系结构

- OSI 七层协议体系结构

物理层 -> 数据链路层 -> 网络层 -> 传输层 -> 会话层 -> 表示层 -> 应用层

- TCP/IP 四层协议体系结构

网络接口层 -> 网络层 IP -> 传输层 TCP/UDP -> 应用层

- 五层协议体系结构

物理层 -> 数据链路层 -> 网络层 -> 传输层 -> 应用层

### 1.2 TCP/IP 协议族

> 包含 IP、TCP、UDP、HTTP、FTP、MQTT 等协议

##### 1.2.1 IP 协议

- 整个 TCP/IP 协议栈的核心协议，负责将数据从源主机发送到目标主机
- IP 协议本身是一种无连接的不可靠数据报交付协议，其协议本身不提供任何错误检查与恢复机制

# 二、TCP 与 UDP

### 2.1 TCP 连接(三次握手)及释放(四次挥手)

![](https://gitee.com/huihut/interview/raw/master/images/TCP-transport-connection-management.png)

##### 2.1.1 TCP 连接异常情况

###### 2.1.1.1 第一次握手丢失

- 客户端超时重传(重传 SYN 报文序列号一样)，可使用`cat /proc/sys/net/ipv4/tcp_syn_retries`查看 SYN 报文最大重传次数
- 通常来说，第一次超时重传在 1 秒后，第二次在 2 秒后，第三次超时重传在 4 秒后 -> ==每次超时重传时间是上一次的两倍==
- 若超过重传次数后服务器仍不回应 ACK，此时客户端会断开 TCP 连接(报错)

###### 2.1.1.2 第二次握手丢失

> 第二次握手 SYN-ACK 中的 ACK 是对第一次握手的确认报文，SYN 是服务器发起 TCP 连接建立的报文

- 客户端以为第一次握手丢失，此时触发超时重传机制，重传 SYN 报文
- 服务器因为第二次握手丢失无法收到第三次握手，服务器触发超时重传机制，重传 SYN-ACK 报文
- 使用`cat /proc/sys/net/ipv4/tcp_synack_retries`可查看 SYN-ACK 报文最大重传次数

###### 2.1.1.3 第三次握手丢失

- 客户端此时已经进入 ESTABLISH 状态，服务器无法接收第三次握手报文，触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手或达到最大重传次数
- 客户端发送的 ACK 报文是不会主动重传的，当 ACK 丢失后，由服务器重传相对应的报文，再由客户端发送 ACK 报文

##### 2.1.2 TCP 释放异常情况

###### 2.1.2.1 第一次挥手丢失

客户端触发超时重传机制，重传 FIN 报文，可通过`cat /proc/sys/net/ipv4/tcp_orphan_retrie`查看 FIN 报文重传次数，当重传 FIN 报文超过最大重传次数后直接进入 CLOSE 状态

###### 2.1.2.2 第二次挥手丢失

这时与第一次挥手丢失的情况相同，但服务器连接会进入 CLOSE_WAIT 状态

###### 2.1.2.3 第三次挥手丢失

- 此时客户端处于 FIN_WAIT_2 状态，服务器处于 LAST_ACK 状态
- 服务器重传 FIN 报文，重传次数根据`tcp_orphan_retrie`确定

###### 2.1.2.4 第四次挥手丢失

- 客户端进入 TIME_WAIT 状态，服务器处于 LAST_ACK 状态
- 服务器重发 FIN 报文，重传次数根据`tcp_orphan_retrie`确定

##### 2.1.2 TCP 协议特点

- 面向连接
- 面向字节流
- 点对点传输
- 提供可靠传输
- 提供拥塞控制
- 提供全双工通信

##### 2.1.3 TCP 黏包问题解决

- 发送定长包。如果每个消息的大小都是一样的，那么接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息
- 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体
- 在数据包之间设置边界，如添加特殊符号  `\r\n`  标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有  `\r\n`，则会误判为消息的边界
- 使用更加复杂的应用层协议

##### 2.1.4 TCP 滑动窗口

**滑动窗口**是 TCP 协议中的一个重要机制，用于**控制、管理发送方和接收方之间的数据传输**。是 TCP 实现流量控制和拥塞控制的基础

### 2.2 UDP 协议特点

- 面向无连接，不提供可靠传输
- 面向数据报文
- 点对点、点对多点、多点对点(单播、多播和广播)
- 尽可能提供交付数据服务，出现错误直接丢弃，无反馈
- 没有握手、确认、滑动窗口、超时重传和拥塞控制等机制，但速度快

### 2.3 UDP 特性-广播

[UDP 特性之广播 \| 爱编程的大丙](https://subingwen.cn/linux/broadcast/)

广播的 UDP 的特性之一，通过广播可以向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的 IP 地址，这个 IP 中子网内主机标志部分的二进制全部为 1 （即点分十进制 IP 的最后一部分是 255），例如 192.168.1.100/24 对应的广播地址为 192.168.1.255/24

基于 UDP 虽然可以进行数据的广播，但是这个属性默认是关闭的，如果需要对数据进行广播，那么需要在广播端代码中开启广播属性，需要通过套接字选项函数进行设置：

```c
int setsockopt(int sockfd, int level, int optname, 	const void *optval, socklen_t optlen);
```

使用 UDP 在局域网范围内进行消息的广播，一般情况下广播端只发送数据，接收端只接受广播消息。因此在数据接收端需要绑定固定的端口，广播端则不需要手动绑定固定端口，自动随机绑定即可

- 发送广播端

```c
// 创建套接字
// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp
int fd = socket(AF_INET, SOCK_DGRAM, 0);

// 主动发送数据不需要手动绑定固定端口（自动随机分配就可以了），因此直接设置广播属性
int opt  = 1;
setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &opt, sizeof(opt));

// 使用广播地址发送广播数据到接收端绑定的固定端口上
sendto();

// 关闭套接字
close(fd);
```

- 接收广播端

```c
// 创建套接字
// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp
int fd = socket(AF_INET, SOCK_DGRAM, 0);

// 因为是被动接收数据的一端，所以必须要绑定固定的端口和本地IP地址
bind();

// 接收广播消息
recvfrom();

// 关闭套接字
close(fd);
```

### 2.3 UDP 特性-组播(多播)

[UDP 特性之组播（多播） \| 爱编程的大丙](https://subingwen.cn/linux/multicast/)

组播是主机间一对多的通讯模式，是一种允许一个或多个组播源发送同一报文到多个接收者的技术。组播源将一份报文发送到特定的组播地址，组播地址不同于单播地址，它并不属于特定某个主机，而是属于一组主机。一个组播地址表示一个群组，需要接收组播报文的接收者都加入这个群组

UDP 的广播与组播：

- 广播只能在局域网访问内使用，组播既可以在局域网中使用，也可以用于广域网
- 在发送广播消息的时候，连接到局域网的客户端不管想不想都会接收到广播数据，组播可以控制发送端的消息能够被哪些接收端接收，更灵活和人性化
- 广播使用的是广播地址，组播需要使用组播地址
- 广播和组播属性默认都是关闭的，如果使用需要通过 setsockopt()函数进行设置

组播需要使用组播地址，在 IPv4 中它的范围从 224.0.0.0 到 239.255.255.255，并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类：

|          IP 地址          |                                                           说明                                                            |
| :-----------------------: | :-----------------------------------------------------------------------------------------------------------------------: |
|   224.0.0.0~224.0.0.255   | 局部链接多播地址：是为路由协议和其它用途保留的地址，只能用于局域网中，路由器是不会转发的地址 224.0.0.0 不能用，是保留地址 |
|   224.0.1.0~224.0.1.255   |                                为用户可用的组播地址（临时组地址），可以用于 Internet 上的                                 |
| 224.0.2.0~238.255.255.255 |                                     用户可用的组播地址（临时组地址），全网范围内有效                                      |
| 239.0.0.0~239.255.255.255 |                                       为本地管理组播地址，仅在特定的本地范围内有效                                        |

> 发送端和接收端设置组播属性
> level 指定为 IPPTOTO_IP, optname 指定为 IP_MULTICAST_IF
> int setsockopt(int sockfd, int level, int optname, const void \*optval, socklen_t optlen);

- 发送端

```c
// 创建套接字
// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp
int fd = socket(AF_INET, SOCK_DGRAM, 0);

// 主动发送数据的一端不需要手动绑定端口（自动随机分配就可以了），设置UDP组播属性
// 设置组播属性
struct in_addr opt;
// 将组播地址初始化到这个结构体成员中
inet_pton(AF_INET, "239.0.1.10", &opt.s_addr);
setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &opt, sizeof(opt));

// 使用组播地址发送组播消息到固定的端口（接收端需要绑定这个端口）
sendto();

// 关闭套接字
close(fd);
```

- 接收端

```c
// 创建套接字
// 第二个参数是 SOCK_DGRAM, 第三个参数0表示使用报式协议中的udp
int fd = socket(AF_INET, SOCK_DGRAM, 0);

// 绑定固定的端口，发送端应该将数据发送到接收端绑定的端口上
bind();

// 加入到组播的群组中，入群之后就可以接收组播消息
struct ip_mreqn opt;
// 要加入到哪个多播组, 通过组播地址来区分
inet_pton(AF_INET, "239.0.1.10", &opt.imr_multiaddr.s_addr);
opt.imr_address.s_addr = INADDR_ANY;
opt.imr_ifindex = if_nametoindex("ens33");
setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &opt, sizeof(opt));

// 接收组播数据
recvfrom();

// 关闭套接字
close(fd);
```

# 三、两者区别

1. TCP 面向连接，UDP 是无连接的；
2. TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付
3. TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道
4. 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多的交互通信
5. TCP **面向字节流**（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是**面向报文**的（不会出现黏包问题）
6. UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）
7. TCP 首部开销 最小 20 字节，最大 60 字节；UDP 的首部开销小，只有 8 个字节
8. 适用场景：TCP 适用于要求高可靠性传输的应用如文本传输，UDP 适用于实时应用如视频电话、视频会议等
