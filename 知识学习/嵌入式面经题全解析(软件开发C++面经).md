> 来源：[111 道嵌入式面经题全解析软件开发面经 C++面经\_牛客网](https://www.nowcoder.com/discuss/419423154676789248)
> 参考：
>
> - [嵌入式面试题-CSDN 博客](https://blog.csdn.net/qq_55960668/article/details/127645285)
> - [角色人生-CSDN 博客](https://blog.csdn.net/SWK_dy/article/list/1)

# 一、进程与线程

[进程与线程](进程与线程.md)
[进程与线程的一个简单解释 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)
[Linux 教程 | 爱编程的大丙](https://subingwen.cn/linux/#%E7%AC%AC3%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B)

### 1.1 基本概念

##### 1.1.1 进程、线程及其区别

- 进程(程序的一次执行过程)

**进程是程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位**

- 线程

**线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位**

##### 1.1.2 多进程、多线程优缺点

[线程、进程、多线程、多进程 和 多任务 小结\_8 线程的缺点-CSDN 博客](https://blog.csdn.net/zaishuiyifangxym/article/details/89415155)

- 多进程优缺点

> 优点：
> (1) 封闭性和可再现性
> (2) 程序并发执行和资源共享
>
> 缺点：
> (1) 进程切换速度慢
> (2) 进程间内存无法共享，进程间通信也较为麻烦

- 多线程优缺点

> 优点：
> (1) 线程共享进程内存空间，线程创建花费空间小，切换速度快
> (2) 线程间通信方便快捷
>
> 缺点：
> (1) 频繁调度，上下文切换增加系统开销
> (2) 编写、调试代码困难(线程同步)，信号支持不佳

##### 1.1.3 选择使用进程还是线程

- 频繁创建销毁的优先用线程
- 进行大量计算的优先使用线程
- 强相关的处理用线程，弱相关的处理用进程

##### 1.1.4 多进程、多线程同步方式

- 多进程同步

管道、信号量、信号、消息队列、共享内存、socket

- 多线程同步

锁、信号量、信号、屏障

##### 1.1.5 进程的空间模型

虚拟空间地址从低到高：代码段->数据段->堆->支持库映射段->栈->内核空间

##### 1.1.6 进程线程的状态转换图、阻塞和就绪条件

- 三状态转换图、五状态转换图
- 阻塞：运行态进程由于需要等待像 I/O 申请等事件完成而进入阻塞态
- 就绪：刚创建好的进程默认就绪态；缺少 CPU 时间片的运行态会进入就绪态；阻塞态的事件完成后进入就绪态

##### 1.1.7 父子进程关系及区别

子进程在 Linux 上使用 fork()从父进程创建而来，几乎复制了父进程的所有信息，比如 UID&GID、环境变量、打开的文件等等，但像 PID、父进程加锁及挂起的信号等信息不会继承过来

##### 1.1.8 进程上下文和中断上下文

- 进程上下文：进程执行时，CPU 所有寄存器的值、进程状态及堆栈中的信息
- 中断上下文：硬件的中断信号使内核调用中断处理程序进入内核空间时，传递给内核的硬件信息、参数及被中断进程的相关环境

##### 1.1.9 一个进程最多可以创建的线程数

- 该问题中最多能创建的线程数与进程的虚拟内存空间大小和系统参数限制

### 1.2 并发、同步异步、互斥、阻塞非阻塞

##### 1.2.1 线程同步和互斥

- 线程同步：线程间存在依赖关系，线程 B 需要等待线程 A 执行完毕后才能继续执行
- 线程互斥：线程间对同一临界资源实现安全访问，同一时刻只能有一个线程通过竞争抢占到对该资源的访问，其他线程此时均不能访问该资源

##### 1.2.2 线程同步与阻塞的关系，同步一定阻塞吗？阻塞一定同步吗？

[一文为你讲解清楚并发，同步，异步，互斥，阻塞，非阻塞-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1829301)

- 线程同步是一个过程，线程阻塞是线程的一种状态
- 线程同步不一定发生阻塞，线程同步的时候，需要协调推进速度，只有当访问同一资源出现互相等待和互相唤醒的时候才会发生阻塞。而阻塞了一定是同步，后访问的等待获取资源，线程进入阻塞状态，借以实现多线程同步的过程

##### 1.2.3 同步/异步、并发、互斥、阻塞/非阻塞

- 同步执行：顺序执行，执行完一个任务后再接着执行下一个任务(需要等待、协调运行)
- 异步执行：任务彼此独立，不用在等待某个任务完成后才继续执行其他任务)(PS：异步执行是最终目的，而线程是异步执行的一种实现方式)

- 线程同步：同一个资源当一个线程正在访问时，其他线程需要等待它访问结束才能访问该资源(顺序访问)；线程间存在依赖关系
- 线程互斥：与线程同步类似，但线程互斥无法控制线程对资源的访问顺序(无序访问)

[一文搞懂程序、进程、线程、并发、并行、高并发的概念](https://blog.csdn.net/Long_xu/article/details/135730509)

- 并发：一个系统能同时处理多个任务(将一个处理器按照时间片分给不同程序执行)
- 并行：系统同时能执行多个任务且每个任务都是在不同处理器核心上执行(真正意义上的同时执行)

- 阻塞：等待子函数执行结束主函数才会继续往下执行
- 非阻塞：不等待子函数执行结束就返回，主函数继续往下执行

### 1.3 孤儿进程、僵尸进程和守护进程

##### 1.3.1 相关概念

- 孤儿进程：父进程不等待子进程就提前结束，此时的子进程被称为孤儿进程
- 僵尸进程：子进程结束后，父进程没对其进行处理(调用 wait()或 waitpid()获取子进程状态信息)时，此时的子进程就被称为僵尸进程；若父进程直到结束都未对该子进程进程处理，那么这个僵尸进程会被 init 进程领养变为孤儿进程；若父进程处于死循环，那这个僵尸就会一直占用着对应的进程号等资源(init 进程是用户空间的第一个进程)
- 守护进程：处于后台运行、长期存在的进程，随系统启动而启动、系统关闭而结束

##### 1.3.2 如何创建守护进程

参见[1.7.3 守护进程](进程与线程.md#1.7.3%20守护进程)

##### 1.3.3 如何正确处理僵尸进程

- 杀掉该僵尸进程的父进程
- 在父进程中对子进程结束时发出的 SIGCHLD 信号调用 wait()或 waitpid()函数进行处理

# 二、C/C++高频知识点

### 2.1 C 与 C++间的区别

##### 2.1.1 new 和 malloc 区别

参见[C&C++ 内存分配](C&C++%20内存分配.md)

- new 除分配内存空间外还会对该内存空间进行初始化
- new 返回指向已分配内存空间的指针是对应对象类型的指针，malloc 则返回 void\*
- new 分配内存失败会抛出 bad_alloc 异常，malloc 则返回 NULL 指针

##### 2.1.2 malloc 的底层实现

malloc 底层实现主要是通过 brk()和 mmap() 分配内存的，详情见[1.1.3 malloc 底层实现内存分配方式](C&C++%20内存分配.md#1.1.3%20malloc%20底层实现内存分配方式)

##### 2.1.3 只有 1G 内存的计算机中能否使用 malloc 分配 1.2G 内存空间？

- 是有可能分配成功的，malloc 分配内存是向进程的虚拟空间中申请内存，与实际物理内存没有直接关系，后面程序运行用到的物理内存由操作系统在第一次访问时发生缺页中断进入内核空间完成虚拟地址到物理地址的映射(硬件单元 MMU 实现映射)
- 实验发现：即使往 1.2G 内存空间读写数据，只要 1G 内存加上 swap 分区大于 1.2G 就不会被系统 kill 掉，否则会触发了 OOM(Out Of Memory)导致进程被 kill 掉

##### 2.1.4 指针与引用的异同，如何相互转换

详见[指针与引用](指针与引用.md)

指针和引用之间使用解引用(\*)和取地址(&)运算符实现指针和引用的相互转换

##### 2.1.5 C 语言内存分配方式、程序内存空间分布

- 内存分配方式
  - 分配自**静态存储区**：分配的内存在编译期间就确定，程序运行结束后才会释放(全局变量和 static 变量)
  - 分配自**栈**：编辑器自动分配和释放(函数实参、局部变量等)
  - 分配自**堆**：程序员手动分配和释放，未手动释放程序结束时**可能**由操作系统回收
- 程序内存空间分布(参见[1.4 进程空间分布](进程与线程.md#1.4%20进程空间分布))
  - 栈：临时变量存储，自动分配与释放(操作方式类似于数据结构中的栈)
  - 堆：动态内存存储，手动分配与释放(与数据结构中的堆不同，分配方式类似于数据结构中的链表)
  - BSS 段(未初始化数据)
  - Data 段(初始化后的数据)
  - Text 段(程序段)：程序代码在内存中的映射

Text、BSS 和 Data 段在编译时就决定了该程序进程将会占用的虚拟空间大小

##### 2.1.6 extern "C"作用

- 主要用在 C 和 C++混合开发的项目中，避免由于编译 C 与 C++函数时的处理不同导致链接失败
- 这里是 C++将 extern "C"修饰的函数调用的地方使用 C 语言的方式进行编译得到不含函数形参类型的链接符号，保证与 C 代码进行链接时不会出错

详见[extern 关键字](extern关键字.md)

##### 2.1.7 头文件中的声明可以使用 extern 进行声明，而在对应源文件中进行定义(**多次声明，一次定义**)

##### 2.1.8 函数参数压栈顺序

详见[函数调用](函数调用.md)

![](https://img2023.cnblogs.com/blog/2883666/202308/2883666-20230816142808449-1354010411.png)

##### 2.1.9 重写 memcpy()函数

详见[memcpy()函数](<memcpy()函数.md>)

主要是地址重叠问题(针对源数据地址被覆盖问题)

- 向前重叠 -> 源数据前面部分被目标数据覆盖
- 向后重叠 -> 源数据后面部分被目标数据覆盖

##### 2.1.10 数组存放位置

见[深入理解 C 语言数组与内存分配-CSDN 博客](https://blog.csdn.net/weixin_44793395/article/details/106292650)

按照数组定义方式的不同而不同，如果数组定义为全局变量，则存储在 data 段或 bss 段；若定义为局部变量，则存储在栈区；若使用 new 定义则存储在堆区(==定义在函数内部时的局部数组时，数组的大小可以使用变量；但使用 static 进行修饰的函数内部的局部数组或者是全局的数组，数组大小不可使用变量==)

##### 2.1.11 struct 和 class 的区别

详见[struct 和 class](struct和class.md)

- struct 默认访问权限为 public，class 默认访问权限为 private
- struct 中成员函数操作较为简单，class 成员函数操作复杂

##### 2.1.12 char 和 int 的转换

- [C/C++ int 和 char 相互转换-猿说编程](https://www.codersrc.com/archives/11297.html)
- [C 学习笔记：char 与 int 互转 - mrcn - 博客园](https://www.cnblogs.com/mrcn/p/cpp-inttochar.html)
- [Linux 下没有 itoa-CSDN 博客](https://blog.csdn.net/zr1076311296/article/details/51534531)

- char --> int

```cpp
// 方式1
char cnum = '1'; // ASCII码为49
int inum = cnum - 48; // ASCII码中48对应字符0
int inum = cnum - '0';

// 方式2
#include<stdlib.h>
/*
*描述：将一个char类型转为整数
*
*参数：
* [in] c：字符类型
*
*返回值：返回char类型对应的整数
*/
int atoi(char *c);
```

- int --> char

```cpp
// 方式1
int inum = 1;
char cnum = inum + 48;

// 方式2
// 注意：这种方式只能在Windows下使用，Linux下无法使用，若确实需要将整数转换为char*字符串则可以使用sprintf()实现跨平台
#include<stdlib.h>
/*
*描述：将一个整数转为char*字符串类型
*
*参数：
* [in] value：整数类型
* [in] c：字符类型
* [in] radix：整数类型，转换后的进制类型，可以转为二进制/八进制/十六进制
*
*返回值：指向这个字符串的指针
*/
char *itoa(int value,char *c,int radix);

// sprintf()实现
char buffer[20];
int n = 123;
sprintf(buffer,"%d",n);
// buffer中保存的就是字符串123
```

##### 2.1.13 static 的用法

详见[static 关键字](static关键字.md)

```cpp
static int static_int = 1;
static void func();
```

##### 2.1.14 const 常量与 define 的区别(编译阶段、安全性、内存占用等)

详见[二、 define 与 const 常量区别](C&C++基础知识总结.md#二、%20define%20与%20const%20常量区别)

- const 在编译阶段处理，\#define 在预处理阶段处理
- const 会进行类型检查，\#define 不会进行类型检查
- const 会分配存储空间，\#define 不会分配存储空间

##### 2.1.15 volatile 作用和用法

[C/C++ 中 volatile 关键字详解 | 菜鸟教程](https://www.runoob.com/w3cnote/c-volatile-keyword.html)
[volatile 关键字的作用和应用场景【面试备用】-CSDN 博客](https://blog.csdn.net/qq_39486027/article/details/113786920)

- 关键词 volatile 表示使用它声明的变量可以被某些编译器以外的未知因素更改，如操作系统、硬件和其他线程等，当使用 volatile 修饰变量时，编译器不会优化该变量，确保每次访问该变量时都重新从内存中读取数据而非 CPU 寄存器
- 由于访问寄存器速度快于内存，所以编译器一般会优化代码减少对内存的读取，但这样可能导致读取到脏数据(寄存器和内存中的数据不同)

##### 2.1.16 C/C++中变量作用域

详见[变量作用域分类](变量作用域分类.md)

- 全局作用域
- 局部作用域

##### 2.1.17 C++中的类型转换机制

详见[类型转换](类型转换.md)

- 编译阶段转换
  - static_cast
  - const_cast
  - reinterpret_cast
- 运行时转换：dynamic_cast

### 2.2 封装、继承与多态

详见[类的继承](类的继承.md)
[C++ 同类不同对象的互相访问 - scyq - 博客园](https://www.cnblogs.com/scyq/p/12431163.html)

**C++ 允许同一个类的不同对象（实例）访问彼此的私有成员**，**封装是针对类而不是对象**，同类之间所有的成员访问权限都是 public，都能互相访问，**在类的成员函数中可以访问同类型实例对象的私有成员**

##### 2.2.1 继承与虚继承

##### 2.2.2 多态类的内存布局

##### 2.2.3 派生类如何调用基类的同名函数和成员变量

添加基类作用域显示调用基类同名函数和成员变量

```cpp
class A
{
public:
	int i = 0;
};

class B : public A
{
public:
	int i = 10;

	void func()
	{
		cout << i << endl;
		cout << A::i<<endl;
	}
};
```

##### 2.2.4 动态多态实现的三个条件及其实现原理

详见：[C++ 多态机制](C++%20多态机制.md)

- 多态实现条件
  - 虚函数 virtual
  - 虚函数重写/覆盖
  - 基类指针或引用的对象调用虚函数
- 多态实现原理(根据虚函数表确定需要调用函数的地址)
  函数调用时进入到“基类”中去，找到对应虚函数表调用对应函数，若是基类的函数则调用基类的，否则调用派生类的

##### 2.2.5 拷贝构造函数

详见[深拷贝与浅拷贝](深拷贝与浅拷贝.md)

- 拷贝构造函数-深浅拷贝：编译器默认生成的拷贝构造函数为浅拷贝，自定义拷贝构造函数一般为深拷贝
- 拷贝构造函数及用途：用于从一个对象数据生成另一个对象，两个对象完全独立
- 自定义拷贝构造函数时机：类中含有指针成员变量时则需要自定义拷贝构造函数实现深拷贝，否则编译器生成的默认拷贝构造函数只是简单拷贝的指针成员，两者的值相同

##### 2.2.6 析构函数可以抛出异常吗？

详见[二、析构函数(Destructor)](<构造函数与析构函数.md#二、析构函数(Destructor)>)

构造函数无论何时都是可以抛出异常的
析构函数不推荐抛出异常，原因如下：

- 若析构函数抛出异常，那么抛出异常之后的代码不会执行，可能存在资源泄露问题
- 通常代码发生异常时，C++机制会调用已有对象的析构函数来释放资源，若析构函数本身也抛出异常，会造成程序崩溃

##### 2.2.7 调用拷贝构造函数的三种情况

详见[1.3 拷贝构造函数](构造函数与析构函数.md#1.3%20拷贝构造函数)

- 使用一个对象初始化另一个对象
- 函数形参为类对象(不是类对象指针或引用)
- 函数返回值为类对象值的形式

##### 2.2.8 析构函数一般写成虚函数的原因

详见[2.3 虚析构函数](C++%20多态机制.md#2.3%20虚析构函数)

确保当释放实际指向派生类的基类指针或引用时，派生类对象也能正确释放其资源

##### 2.2.9 构造函数为什么一般不定义为虚函数

- 存储空间角度：虚函数对应一个 vtable，vtable 存储于对象的内存空间：若构造函数是虚的，则需要通过 vtable 来调用，但调用构造函数时对象还未实例化，即未分配内存空间，无法找到 vtable
- 使用角度：虚函数主要用于在信息不全的情况下，能使重写的函数得到正确的调用，构造函数本身就是要初始化实例(知道需要初始具体类对象)，使用虚函数没有实际意义
- 从实际含义上看，在调用构造函数时还不能确定对象的真实类型（因为子类会调父类的构造函数）；而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数

##### 2.2.10 纯虚函数

[c++虚函数与纯虚函数的理解及使用场合 - hellogiao1 - 博客园](https://www.cnblogs.com/hellogiao1/p/14899426.html)

- 纯虚函数代表基类函数未被实现，必须由派生类对其进行实现
- 定义纯虚函数目的是实现一个接口，继承该类的派生类必须实现该函数，含有纯虚函数的类称为抽象类，**抽象类不能实例化**

```cpp
class A
{
public:
	virtual void func() = 0;
}
```

##### 2.2.111 静态绑定与动态绑定

详见：[一、多态性](C++%20多态机制.md#一、多态性)

- 静态绑定：通过函数重载和模板在编译期实现绑定
- 动态绑定：通过虚函数和继承在运行时实现绑定

##### 2.2.12 C++构造/析构函数分类

详见[构造函数与析构函数](构造函数与析构函数.md)

- 默认构造函数
- 普通构造函数
- 拷贝构造函数
- 移动构造函数
- 析构函数

##### 2.2.13 重写、重载和覆盖的区别

详见[1.3 重载、重写(覆盖)与隐藏](<C++%20多态机制.md#1.3%20重载、重写(覆盖)与隐藏>)

- 重写：继承体系中派生类重写基类中 virtual 修饰的同名且形参相同的函数
- 重载：同类中具有相同的函数名和返回类型但函数形参不同
- 隐藏：派生类中屏蔽掉基类中具有相同函数名的函数

```cpp
class A
{
public:
	virtual func();
	// 函数重载 func1()与func1(int a)
	void func1();
	void func1(int a);

	void func2();
};

class B : public A
{
public:
	// 函数重写/覆盖 B::func()覆盖 A::func()
	virtual func();
	// 函数隐藏 B::func2()隐藏 A::func2()
	void func2();
}
```

##### 2.2.14 成员初始化列表

- [窥视 C++细节-为什么成员初始化列表更快-CSDN 博客](https://blog.csdn.net/qiuguolu1108/article/details/114800002)
- [成员初始化列表的概念，为什么用它会快一些？-CSDN 博客](https://blog.csdn.net/salmonwilliam/article/details/114259002)
- [《逆袭进大厂》第二弹之 C++进阶篇 59 问 59 答(4W 字超强汇总)](https://zhuanlan.zhihu.com/p/349967745)

```cpp
class A
{
public:
	// 成员初始化列表
	A(int t) : a(t){}
private:
	int a;
};

class B
{
public:
	// 类对象成员 普通初始化
	B(int t)
	{
		b = A(t);
	}
	// // 类对象成员 成员初始化列表
	// B(int t) : b(t);
private:
	A b;
};
```

- 赋值初始化，通过在函数体内进行赋值初始化，该方式是在所有数据成员分配内存空间后才执行函数体中的代码
- 列表初始化，在冒号后使用初始化列表进行初始化，列表初始化是给数据成员分配内存空间时就进行初始化，此时构造函数体还未执行
- 待初始化成员是类对象
  - 不采用成员初始化列表而放到构造函数体中初始化：先执行一次默认构造函数实例化类 A 得到对象 b ，再执行一次有参构造函数实例化对象 A(t)，再执行一次赋值运算符将 A(t)赋值给 b，最后执行一次析构函数释放 A(t)
  - 采用成员初始化列表：直接调用有参数的构造函数 A(t)生成对象 b

##### 2.2.15 如何避免编译器进行隐式类型转换

详见[十二、explicit 关键字](C&C++基础知识总结.md#十二、explicit%20关键字)

使用 explicit 声明构造函数需进行显示调用而非隐式调用

# 三、网络编程

详见：[TCP 与 UDP](TCP与UDP.md)

### 3.1 TCP 与 UDP

##### 3.1.1 TCP 与 UDP 的区别

|            |               TCP                |            UDP             |
| :--------: | :------------------------------: | :------------------------: |
|   连接性   |             面向连接             |         面向无连接         |
| 传输可靠性 | 保证可靠传输(流量和拥塞控制实现) |       不保证可靠传输       |
|  传输方式  |            面向字节流            |          面向报文          |
| 连接对象数 |            点对点通信            |      单播、多播和广播      |
|  首部开销  |         首部 20~60 字节          |     首部开销仅 8 字节      |
|  适用场景  |   高可靠传输应用场景(文件传输)   | 实时应用(视频会议、直播等) |

##### 3.1.2 TCP 与 UDP 的优缺点

- TCP 优缺点
  - 优点：可靠性传输
  - 缺点：效率低，占用资源高
- UDP 优缺点
  - 优点：效率高
  - 缺点：不可靠性传输

##### 3.1.3 TCP 和 UDP 的适用场景

- TCP：要求高可靠性传输的应用
- UDP：实时应用

##### 3.1.4 TCP 为什么可以实现可靠连接

- 滑动窗口机制 -> 实现流量控制和拥塞控制
- 超时重传机制：见[七、TCP 重传机制](2024.8.14%20经纬恒润面试%20一面.md#七、TCP%20重传机制)

##### 3.1.5 典型网络模型

[三种网络模型（OSI 七层参考模型、TCP/IP 参考模型、五层参模型）](https://blog.csdn.net/weixin_44417441/article/details/113769242)
[OSI 参考模型基本介绍、各层功能及数据传输过程-CSDN 博客](https://blog.csdn.net/qq_46456049/article/details/109257415)

- 资源子网：包括会话层、表示层和应用层
- 通信子网：包括物理层、数据链路层和网络层

* OSI 七层参考模型
  - 应用层：为应用程序提供服务
  - 表示层：数据格式转化、数据加密
  - 会话层：建立、管理和维护会话
  - 传输层：建立、管理和维护端到端的连接
  - 网络层：IP 选址及路由选择
  - 数据链路层：提供介质访问和链路管理
  - 物理层：bit 流传输(物理层)
* TCP/IP 四层参考模型
  - 应用层
  - 传输层
  - 网络层
  - 网络接口层
* 五层参考模型
  - 应用层
  - 传输层
  - 网络层
  - 数据链路层
  - 物理层

##### 3.1.6 http 1.1 和 http 1.0 的区别

[面试常问：HTTP 1.0 和 HTTP 1.1 有什么区别？ - JavaGuide - 博客园](https://www.cnblogs.com/javaguide/p/16593084.html)

1. **连接方式** : HTTP 1.0 为短连接，HTTP 1.1 支持长连接
2. **状态响应码** : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，`100 (Continue)`——在请求大资源前的预热请求，`206 (Partial Content)`——范围请求的标识码，`409 (Conflict)`——请求与当前资源的规定冲突，`410 (Gone)`——资源已被永久转移，而且没有任何已知的转发地址
3. **缓存处理** : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略
4. **带宽优化及网络连接的使用** :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接
5. **Host 头处理** : HTTP/1.1 在请求头中加入了`Host`字段

##### 3.1.7 URI 和 URL 的区别

- URL(统一资源定位符) --> 标识和定位互联网资源
  - 网址，例如https://www.baidu.com/
  - 完整定义：协议类型://登录信息(认证)@服务器地址:端口号/带层次的文件路径?查询字符串#片段标识符
- URI(统一资源标识符) --> 标识互联网资源
  - 某个网络协议方案表示的资源定位标识符
- URL 是一个具体的概念，URI 是一个抽象的概念
- URL 是 URI 的子集

### 3.2 三次握手和四次挥手

[计算机网络——TCP 的三次握手与四次挥手（超详细） - 特务依昂 - 博客园](https://www.cnblogs.com/tuyang1129/p/12435772.html)

##### 3.2.1 为什么是三次握手

- 客户端向服务器发送建立连接的 TCP 报文(SYN 报文段)
- 服务器向客户端发送允许连接的 TCP 报文(SYN ACK 报文段) -> 可分为两个包发送
- 客户端向服务器发送连接建立的确认报文(SYN ACK 报文段)

##### 3.2.2 为什么三次握手中客户端需要在接收到服务器允许连接的 TCP 报文后还需要再发送一次确认？可以改为二次握手吗？

- 说法 1：客户端和服务器的握手过程不仅是互相确认是否可达，更重要的是同步，第一次握手客户端发送报文序号给服务器，第二次握手服务器发送报文序号给客户端，第三次握手是客户端告诉服务器，客户端接收到服务器报文序号，完成同步操作，可以开始传输数据(若没有第三次握手，服务器将无法保证客户端接收到了自己的`SYNACK`报文段，若此时`SYNACK`报文段丢失，客户端不知道服务器的初始序号，将无法处理之后到达客户端的数据)
- 说法 2：若只有两次握手，当客户端第二次发送的 SYN 报文被服务器收到并完成后续的 TCP 建立过程；第一次发送 SYN 报文才到达服务器，这时服务器会再次分配资源并维持 TCP 连接，导致服务器资源的浪费

##### 3.2.3 为什么服务器易受到 SYN 攻击

[SYN 泛洪攻击详解 - 贾维斯 Echo - 博客园](https://www.cnblogs.com/taoxiaoxin/p/13974351.html)

- SYN 攻击利用 TCP 三次握手机制，攻击方通过利用伪造的 IP 地址向服务器发送请求，而服务器发送的 SYNACK 报文段无法到达目的地，导致服务器在等待关闭这个连接过程中持续消耗资源，当存在成千上万的 SYN 攻击连接时导致服务器资源被耗尽，从而实现攻击的目的
- 服务器端资源分配在二次握手时完成，客户端资源分配在三次握手时完成

##### 3.2.4 为什么客户端四次挥手最后在 TIME-WAIT 状态需要等待 2MSL

- 当客户端接收到服务器发送的`FIN`报文后（第三次挥手），会回送一条确认报文（第四次挥手），但是，客户端并不知道这条确认报文是否可以顺利到达服务器。若这条确认报文在传送到服务器的过程中损坏、丢失或超时，将引起服务器重新发送`FIN`报文，客户端接收到后，将需要再次发送一条确认报文，直到服务器正确接收。但是，客户端发送确认报文后，立刻释放资源，将导致无法处理重传的`FIN`报文，所以客户端需要等待一段时间，直到确认没有出现上述情况出现再释放资源
- 四次挥手完成后，理论上已经断开了连接，但是这不代表之前通过这条连接发送的所有数据都处理完毕了，有些可能还在网络中传输。若在四次挥手后，立即释放客户端的资源，然后客户端立即以同一个源端口，向服务器的同一个目的端口再次建立一个`TCP`连接，这个连接和上一个的 源端口+源`IP`+目的端口+目的`IP`  都一模一样，此时将会产生问题。若上一次连接遗留在网络中的报文此时到达，将会被当做新连接传输的数据处理，于是可能会产生一些不可预估的错误。所以，客户端在断开连接后，需要等待一段时间，直到网络中遗留的数据都消失，才释放资源，而在资源没有被释放前，是不允许建立一个 源端口+源`IP`+目的端口+目的`IP`  都一模一样的`TCP`连接的（因为`TCP`套接字由这四部分标识）

##### 3.2.5 为什么建立连接时三次握手，关闭连接时四次挥手

- TCP 建立连接时需要三次握手原因见[3.2.2 为什么三次握手中客户端需要在接收到服务器允许连接的 TCP 报文后还需要再发送一次确认？可以改为二次握手吗？](#3.2.2%20为什么三次握手中客户端需要在接收到服务器允许连接的%20TCP%20报文后还需要再发送一次确认？可以改为二次握手吗？)
- TCP 关闭连接时需要四次挥手原因：
  - 理论上，断开连接只需要两次挥手(其中一方请求断开连接，另一方确认即可)，但由于 **TCP 连接是全双工**的，因此需要客户端和服务器双方各自发起一次断开连接请求，另一方确认
  - 关闭连接时，服务器收到客户端的 FIN 报文时，仅标识客户端不再发送数据了但是服务器还能接收数据，且服务器也未必把全部数据都发送给对方了，所以服务器可以立即关闭，也可以将全部数据发送给客户端后，再发送 FIN 报文给对方来表示同意关闭连接

# 四、常见算法

### 4.1 排序算法

##### 4.1.1 各种排序算法的时间空间复杂度和稳定性

稳定性：待排序的序列中存在多个相同的值，那么排序后这些相同值的相对位置不改变，则称该排序算法是稳定的，否则称为不稳定的

见[七、排序算法](数据结构与算法知识点.md#七、排序算法)

- 平均时间复杂度
  - $O(n^2)$：冒泡排序、选择排序、插入排序
  - $O(n*log_2n)$：快速排序、堆排序、归并排序、希尔排序
- 空间复杂度
  - $O(1)$：冒泡排序、选择排序、插入排序、堆排序、希尔排序
  - $O(log_2n)$：快速排序
  - $O(n)$：归并排序
- 稳定性
  - 不稳定：快速排序、堆排序、希尔排序、选择排序 --> **快选堆希**
  - 稳定：冒泡排序、插入排序、归并排序、计数排序、桶排序 --> **插冒归计桶**

---

- 插入排序
  - 直接插入排序算法
  - 希尔排序算法
- 选择排序
  - 选择排序算法
  - 堆排序算法
- 交换排序
  - 冒泡排序算法
  - 快速排序算法
- 归并排序
  - 归并排序算法

##### 4.1.2 各种排序算法什么时候有最好情况和最坏情况

各种排序算法的最好和最坏情况的资料同上
快速排序最坏情况退化为冒泡排序，需要比较$\frac{n*(n-1)}{2}$次

##### 4.1.3 冒泡排序算法

详见[冒泡排序算法](冒泡排序算法.md)

连续比较相邻元素(从左到右/从右到左)实现冒泡排序

##### 4.1.4 选择排序算法

详见[选择排序算法](选择排序算法.md)

从左到右/从右到左，找到未排序元素区间最小值，再添加到已排序元素区间末尾

##### 4.1.5 插入排序算法

详见[插入排序算法](插入排序算法.md)

将待排序数据与已排序数据进行对比，插入正确的位置(手动整理一副牌)

##### 4.1.6 希尔排序算法

详见[希尔排序算法](希尔排序算法.md)

希尔排序是对直接插入排序的优化，主要是将原本待排序序列分割为多个子序列先进行排序(子序列增量为$t_i$)，等子序列增量变为 1 时再进行一次直接插入排序实现希尔排序整体流程

##### 4.1.7 归并排序算法

详见[归并排序算法](归并排序算法.md)

归并排序算法先将待排序序列递归划分为左右子序列，分别对其进行排序合并

##### 4.1.8 快速排序算法

详见[快速排序算法](快速排序算法.md)

类似归并排序算法，都是采用的分治策略，从序列中选出基准数据，并重新排序使该基准数据位于中间，递归地对基准值两侧的子序列进行排序

##### 4.1.9 快排算法的 partition()和归并排序算法的 merge()函数对比

参考：[快排的 partition 函数与归并的 merge 函数 - CSDN 文库](https://wenku.csdn.net/answer/d6d1ae00e61d424a95b65a2c7fac8f27)

- partition()函数：将序列中的元素分为两个部分，一部分比随机选取的基准数小，一部分比基准数大(基准数在中间)
- merge()函数：将两个已排序序列合并为一个有序序列

### 4.2 STL 标准库

##### 4.2.1 vector 与 list 的对比

见 [四、vector、list 和 deque 对比](STL库之vector、list和deque.md#四、vector、list%20和%20deque%20对比)

- vector 是连续存储的，支持高效随机访问和尾部插入删除操作，但其他位置的插入删除操作效率较低
- list 是非连续存储的，不支持随机访问，但在任何地方都能实现高效插入删除操作
- 当关心高效随机访问而不关心插入删除时推荐使用 vector，反之则推荐 list

##### 4.2.2 vector 内存增长底层实现(1.5 倍/2 倍内存扩容)

见[1.2 vector 内存分配原理](STL库之vector、list和deque.md#1.2%20vector%20内存分配原理)

##### 4.2.3 vector 和 deque 的比较

见 [四、vector、list 和 deque 对比](STL库之vector、list和deque.md#四、vector、list%20和%20deque%20对比)

- vector 与 deque 都支持随机访问，但 deque 效率不如 vector 高
- deque 类似于 vector，但是相较于 vector，能够支持在首尾插入元素

##### 4.2.4 为什么 STL 算法库中有 sort()但 list 中还需要自定义 sort()

[详细解说 STL 排序(Sort) - soqu36 - 博客园](https://www.cnblogs.com/soqu36/articles/11051534.html)
[为什么 stl 里面有 sort 函数而 list 里面还要定义一个 sort - CSDN 文库](https://wenku.csdn.net/answer/6b54b5ec8a104d50b08fb42b2edb97e3)
[关于 sort 无法对 map、sort 排序的问题-CSDN 博客](https://blog.csdn.net/weixin_46585199/article/details/119547356)

- STL 算法库中的 sort()用于对提供==随机访问迭代器==的容器元素进行排序，而 list 底层数据结构是双向链表，提供顺序访问迭代器而不提供随机访问迭代器，无法直接使用 STL 算法库中的 sort()，所以才需要自定义 sort()实现对 list 的排序；同理，map、set 等关系型容器也无法直接调用 sort()进行排序；至于序列式容器如 stack、queue 等则不允许对元素排序
- list 中自定义 sort()采用归并排序算法，STL 算法库中的 sort()采用快速排序算法

##### 4.2.5 STL 底层数据结构

[C++ STL 容器底层数据结构的实现 - 拾月凄辰 - 博客园](https://www.cnblogs.com/FengZeng666/p/9347027.html)
[C++中常见的容器及复杂度-CSDN 博客](https://blog.csdn.net/Destiny_shine/article/details/104291888)

|      容器类型      |                底层数据结构                |              特点              |
| :----------------: | :----------------------------------------: | :----------------------------: |
|       vector       |                    数组                    |          快速随机访问          |
|        list        |                  双向链表                  |          快速增加删除          |
|       deque        |                  两级数组                  | 快速随机访问、首尾快速增加删除 |
|       stack        |        list 或 deque 实现(封闭头部)        |            先进后出            |
|       queue        |        list 或 deque 实现(封闭头部)        |            先进先出            |
|   priority_queue   | vector 为底层容器,将其中的元素构造成堆结构 |            类似于堆            |
|        set         |                   红黑树                   |         有序，不可重复         |
|      multiset      |                   红黑树                   |          有序，可重复          |
|        map         |                   红黑树                   |         有序，不可重复         |
|      multimap      |                   红黑树                   |          有序，可重复          |
|   unordered_set    |                   哈希表                   |         无序，不可重复         |
| unordered_multiset |                   哈希表                   |          无序，可重复          |
|   unordered_map    |                   哈希表                   |         无序，不可重复         |
| unordered_multimap |                   哈希表                   |          无序，可重复          |

##### 4.2.6 使用迭代器删除元素会发生什么

[C++中利用迭代器删除元素会发生什么？-CSDN 博客](https://blog.csdn.net/YF_Li123/article/details/75003425)

- 对于顺序容器(vector、deque、list)：删除当前元素会使后面所有元素迭代器失效(除 list 外)，但 erase()删除元素时会返回下一个元素的有效迭代器
- 对于关联容器(set、map 等)：删除当前元素只会使当前元素迭代器失效，其他元素迭代器仍能正常使用

##### 4.2.7 map 实现方式、查找效率及其排序

[C++ STL 中的 map 用红黑树实现，搜索效率是 O(lgN),为什么不像 python 一样用散列表从而获得常数级搜索效率呢？ - 雪之灵 - 博客园](https://www.cnblogs.com/gofighting/p/5438021.html)
[C++的 map 排序-CSDN 博客](https://blog.csdn.net/chengqiuming/article/details/89816566)
[c++ map 基础知识、按键排序、按值排序 - 简书](https://www.jianshu.com/p/5b24ac2a6cac)

- map 的底层实现数据结构为红黑树，map 查找效率为$O(log_2n)$
- map 默认按照 key 从小到大排序，但有时需要对其进行自定义排序，如下：
- 让 map 按照 key 从大到小排序

```cpp
map<string, int, greater<string>> m;
```

- 让 map 按照 value 而非 key 从小到大排序

```cpp
map<string,int> m;

// 注意：这里务必先把map容器转换为vector容器，因为sort只支持随机访问迭代器而不支持像map、set等非随机访问迭代器
vector<pair<string,int>> v(m.begin();m.end());

sort(v.begin(),v.end(),[](const pair<string,int> &l,const pair<string,int> &r){return l.second < r.second;})
```

##### 4.2.8 几种数据结构的时间复杂度

|  数据结构  |         查找          |    插入     |    删除     |
| :--------: | :-------------------: | :---------: | :---------: |
|    数组    |        $O(n)$         |   $O(1)$    |   $O(n)$    |
|  有序数组  | 二分查找：$O(log_2n)$ |   $O(n)$    |   $O(n)$    |
|   单链表   |        $O(n)$         |   $O(1)$    |   $O(n)$    |
| 有序单链表 |        $O(n)$         |   $O(n)$    |   $O(n)$    |
|   双链表   |        $O(n)$         |   $O(1)$    |   $O(n)$    |
| 有序双链表 |        $O(n)$         |   $O(n)$    |   $O(n)$    |
|   二叉树   |        $O(n)$         |   $O(n)$    |   $O(n)$    |
| 二叉搜索树 |      $O(log_2n)$      | $O(log_2n)$ | $O(log_2n)$ |
|   红黑树   |      $O(log_2n)$      | $O(log_2n)$ | $O(log_2n)$ |
| 平衡二叉树 |      $O(log_2n)$      | $O(log_2n)$ | $O(log_2n)$ |
|   哈希表   |        $O(1)$         |   $O(1)$    |   $O(1)$    |

# 五、Linux 操作系统相关

### 5.1 Linux 系统内核

详见：
[Linux 系统内核](Linux系统内核.md)
[一、Linux 系统启动过程](Linux系统启动流程.md#一、Linux%20系统启动过程)
[第三章 Linux 在 ARM 上的启动流程 | Linux 内核与嵌入式开发](https://wugaosheng.gitbooks.io/linux-arm/content/di-san-zhang-linux-zai-arm-shang-de-qi-dong-liu-cheng.html)

##### 5.1.1 Linux 内核组成

进程管理、内存管理、虚拟文件系统、网络子系统、进程间通信

##### 5.1.2 用户空间与内核通信方式

系统调用、中断、ioctl()等方式

##### 5.1.3 系统调用 read()/write()，内核具体做了哪些事情

[linux 内核剖析（六）Linux 系统调用详解（实现机制分析） - AlanTu - 博客园](https://www.cnblogs.com/alantu2018/p/8991310.html)

用户空间调用`read()` -> 内核空间调用`sys_read()` -> `scull_fops.read` -> `scull_read()`

- 用户空间处理：0x80 软件中断将控制权交给内核
- 内核空间处理：内核接管从用户空间交过来的控制权后，历经过 6 个层次处理最后将请求交给磁盘完成最终数据读写操作

##### 5.1.4 系统调用的作用

> 系统调用是操作系统提供给应用程序(程序员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序发出系统调用请求来获得操作系统的服务
> 系统调用主要是实现资源管理和系统稳定安全，避免用户进行非法操作

- 为用户空间提供了一种统一的硬件抽象接口。比如当需要读写文件的时候，应用程序就可以不去管磁盘类型和介质，甚至不用去管文件所属的文件系统到底是哪种类型
- 系统调用保证了系统的稳定和安全。作为硬件设备和应用程序之间的中间层，内核可以基于权限和其他一些规则对需要进行的访问进行裁决。这样可以避免应用程序不正确地使用硬件设备，窃取其他进程的资源，或做出其他危害系统的事情
- 每个进程都运行在虚拟系统中，而在用户空间和系统的其余部分提供这样一层公共接口，也是出于这种考虑。如果应用程序可以随意访问硬件而内核又对此一无所知的话，几乎就没法实现多任务和虚拟内存，当然也不可能实现良好的稳定性和安全性。在 Linux 中，系统调用是用户空间访问内核的唯一手段；除异常和中断外，它们是内核唯一的合法入口

##### 5.1.5 内核态和用户态的区别

- 内核态进程访问内存空间资源不受限且所占用的处理器不可被抢占
- 用户态进程访问内存空间资源受限且所占用的处理器可被抢占

##### 5.1.6 bootloader、内核和根文件的关系

bootloader -> 内核 -> 根文件

bootloader 加载内核文件到内存中解压缩和执行，内核检测硬件和加载对应驱动程序，启动系统相关服务，等待用户登录使用，根文件存放 Linux 系统重要文件、库和命令等，内核启动后需要对其进行挂载，保证内核的正常运行

##### 5.1.7 bootloader 的启动过程

bootloader 启动过程一般分为两个阶段，详见[二、嵌入式 Linux 系统 boot loader 执行阶段](Linux系统启动流程.md#二、嵌入式%20Linux%20系统%20boot%20loader%20执行阶段)

##### 5.1.8 为什么需要 bootloader

- 引导加载程序是系统上电后运行的第一段软件代码。PC 机中的引导加载程序由 BIOS(其本质就是一段固件程序)和位于硬盘 MBR 中的 OSBootLoader（比如，LILO 和 GRUB 等）一起组成。BIOS 在完成硬件检测和资源分配后，将硬盘 MBR 中的 BootLoader 读到系统的 RAM 中，然后将控制权交给 OSBootLoader。BootLoader 的主要运行任务就是将内核映像文件从硬盘上读到 RAM 中，然后跳转到内核的入口点去运行，即开始启动操作系统
- 简单地说，BootLoader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境

##### 5.1.9 Linux 内核同步方式

详见[Linux 内核同步](Linux内核同步.md)

- 自旋锁
- 信号量
- RCU

##### 5.1.10 为什么自旋锁不能睡眠，而拥有信号量时可以睡眠

[嵌入式 100 题（67）：为什么自旋锁不能睡眠 而在拥有信号量时就可以？-CSDN 博客](https://blog.csdn.net/SWK_dy/article/details/114156377)

主要是==自旋锁禁止处理器抢占而信号量不禁止处理器抢占==(自旋锁禁止处理器抢占持有锁的线程而信号量不会禁止处理器抢占持有信号量的线程)

如果自旋锁在锁住以后进入睡眠，由于不能进行处理器抢占，其他系统进程都不能获得 CPU 时间片运行，不能唤醒睡眠的自旋锁，因此系统将不响应任何操作(除了中断或多核的情况)。而信号量在临界区睡眠后，其他进程可以用抢占的方式继续运行，从而实现内存拷贝等功能使得睡眠的信号量程序获得了等待的资源而被唤醒，从而恢复正常运行

##### 5.1.11 Linux 检查内存状态命令

- `top`：动态查看内存使用状态
- `free -h`：查看内存使用情况
- `cat /proc/meminfo`：查看内存更详细的状态
- `vmstat -s`：类似于`/proc/meminfo`

### 5.2 其他操作系统常见知识点

##### 5.2.1 大小端区别及其各自优缺点

详见[2024.4.24 联发科笔试](2024.4.24%20联发科笔试.md)

- 小端序(little-endian)：低位数据存放在低地址，高位数据存放在高地址 -> Intel、AMD 采用
- 大端序(big-endian)：低位数据存放在高地址，高位数据存放在低地址 -> ARM、motorola 采用

**优缺点：**

- 大端模式：基于其存储特点，符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小
- 小端模式：基于其存储特点，内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容；另外 CPU 做数值运算时从内存中依顺序依次从低位地址到高位地址取数据进行运算，开始只管取值，最后刷新最高位地址的符号位就行，这样的运算方式会更高效一些

##### 5.2.2 源文件到可执行程序的四个过程

详见[编译与链接](编译与链接.md)

预编译 -> 编译 -> 汇编 -> 链接

##### 5.2.3 什么是堆区、栈区，内存泄漏和内存溢出

详见
[可执行程序内存分配](可执行程序内存分配.md)
[什么是堆，栈，内存泄漏和内存溢出？-CSDN 博客](https://blog.csdn.net/Geek_/article/details/99699312)

- 栈区(stack)：操作系统自动分配释放，用于存放函数参数值、局部变量等 -> 从上往下生长(高地址向低地址生长)
- 堆区(heap)：开发人员分配释放，若开发人员未对其进行释放，程序结束时可能由系统释放 -> 从下往上生长(低地址向高地址生长)
- 内存泄漏：由于疏忽或错误造成程序未能正确释放不再使用的内存的情况 -> 失去了对于分配内存的控制，造成内存浪费
- 内存溢出：要求分配的内存大小超出系统最大值，产生溢出

##### 5.2.4 堆和栈的区别

[一文读懂堆与栈的区别-CSDN 博客](https://blog.csdn.net/K346K346/article/details/80849966)

- 程序内存布局中：堆和栈表示两种内存管理方式
- 数据结构中：堆和栈表示两种常用数据结构

##### 5.2.5 产生死锁原因、条件及如何预防

详见[6.2 死锁](进程与线程.md#6.2%20死锁)

- 原因：互相等待对方进程
- 条件：互斥、请求保持、不可剥夺、循环等待
- 预防：避免第 2 ，3，4 个条件的出现

##### 5.2.6 硬链接和软链接的区别

[软链接与硬链接 详细讲解-CSDN 博客](https://blog.csdn.net/Giyomwd/article/details/104143426)

> Linux 系统下的文件是通过索引节点(inode)识别文件

- 硬链接：创建指向同一个 inode 的文件名(类似于同一个文件的别名)，删除其中一个对于另外一个文件完全没有影响，每增加一个指向对应 inode 的文件名，该 inode 节点的链接数会增加一，删除则减少一，当 inode 节点的链接数减为 0 时则系统将会回收该 inode 和对应数据块
- 软链接：类似于 Windows 快捷方式，两个文件的 inode 是不相同的，其中软链接 inode 对应数据块保存的信息是原文件的路径
- 两者区别：
  - 硬链接无法跨分区、跨设备建立硬链接，无法创建目录硬链接，没有主次之分、相互独立
  - 软链接依赖于原文件，原文件被删除，软链接不可用

##### 5.2.7 虚拟内存地址与物理地址转换

通过==(硬件设备)==内存管理单元(MMU)进行虚拟地址到物理地址的映射

##### 5.2.8 32 位(X86)和 64 位(X64)计算机的区别

- 寻址能力：32 位最大支持 4GB 内存寻址，64 位最大能支持上百 GB 内存寻址
- 数据处理能力：32 位计算机 CPU 运行一次只能处理 32 位数据，64 位一次性能处理 64 位数据

##### 5.2.9 中断和异常的区别

[中断和异常的区别|极客教程](https://geek-docs.com/linux/linux-ask-answer/the-difference-between-interrupts-and-exceptions.html)
[操作系统中陷阱，中断和异常的区别 - Broglie - 博客园](https://www.cnblogs.com/broglie/p/5463359.html)
[面试考点——中断和异常的区别-CSDN 博客](https://blog.csdn.net/qq_29996285/article/details/88078939)

- 中断(外中断)：由外部硬件事件引起的程序控制中断，比如键盘鼠标、I/O 端口、磁盘等硬件引起的中断
- 异常(内中断)：由软件引起的中断，即由于程序执行期间发生异常情况导致的，比如除以零、执行非法操作码等操作可能导致异常

| 中断                                               | 异常                                                                         |
| -------------------------------------------------- | ---------------------------------------------------------------------------- |
| 中断是硬件中断                                     | 异常是软件中断                                                               |
| 硬件中断的发生通常会禁用其他硬件中断               | 就异常而言，这不是一个真实的情况                                             |
| 中断是对服务的异步外部请求(如键盘或打印机需要服务) | 异常是基于异常事件的同步内部服务请求(非法指令、非法地址、溢出等)             |
| 由于是异步的，中断可以发生在程序的任何地方         | 由于是同步的，当程序中出现异常事件时会发生异常，例如除以零或非法内存位置访问 |
| 中断是正常事件，不应该干扰程序的正常运行           | 异常是异常事件，通常会导致程序终止                                           |

##### 5.2.10 中断产生及其处理流程

[嵌入式 100 题（77）：中断怎么发生，中断处理大概流程 - 角色人生 - 博客园](https://www.cnblogs.com/swk0918/p/14453309.html)

- 中断是 CPU 接收到来自外围硬件发出的中断请求信号后进行相应的硬件/软件处理
- 中断处理流程：判断是否有中断请求 -> 响应中断请求，关闭中断响应(避免其他中断打断该中断的服务程序执行) -> 保护现场 ->转到对应中断服务程序 -> 恢复现场 -> 打开中断响应 -> 返回继续执行

中断服务程序最后执行的指令是中断返回指令，如 X86 架构中是 IRET 指令；中断服务程序的入口地址则是在中断向量表中设置的

##### 5.2.11 Linux 系统 挂起、休眠和关机命令

[Linux 休眠，挂起(待机)，关机等几个命令的区别及如何实现；如何启用 Ubuntu 的休眠模式...-CSDN 博客](https://blog.csdn.net/vigorlhwjsj/article/details/123813465)

- 挂起：`sudo pm-suspend`
- 休眠：`sudo pm-hibernate`
- 关机：`shutdown -h now/sudo init 0/sudo halt`
- 重启：`sudo reboot/sudo init 6/sudo shutdown -r now`

##### 5.2.12 数据库建立索引原因，索引的缺点

[【数据库】索引的优点和缺点 - 陈泽泽 - 博客园](https://www.cnblogs.com/zeze/p/9608878.html)
[mysql 如何创建索引，为什么要创建索引，创建索引的缺点-CSDN 博客](https://blog.csdn.net/hzq980102/article/details/116617533)

- 优点(建立索引原因)
  - 有效缩短数据检索时间，==提高数据查询效率==
  - 加快表与表之间的连接
- 缺点
  - 创建维护索引需要的==时间和空间成本且会随着数据量增大而增大==
  - ==降低表的增删改效率==

##### 5.2.13 CPU、内存、硬盘的关系

[嵌入式 100 题（80）：内存 虚拟内存 磁盘/硬盘 的关系-CSDN 博客](https://blog.csdn.net/SWK_dy/article/details/114199475)

- CPU(central processing unit/中央处理器)：CPU 从内存或缓存中取出指令，放入指令寄存器，并对指令译码分解成一系列的微操作，然后发出各种控制命令，执行微操作系列，从而完成系统指令的执行
- 内存：CPU 并不能直接调用存储在硬盘上的系统、程序和数据，必须首先将硬盘的东西搬到内存中，才能被 CPU 读取运行。因而，内存(即物理内存，是相对于硬盘这个“外存”而言)作为硬盘和 CPU 的“中转站”，对电脑运行速度有较大影响
  - 物理内存：真实存在的内存条
  - 虚拟内存：使用硬盘空间作为物理内存来使用，弥补物理内存空间的不足，这里与程序进程的虚拟内存空间有所不同
- 硬盘：由于内存是带电存储的(一旦断电数据就会消失)，而且容量有限，所以要长时间储存程序或数据就需要使用硬盘(外存储器)。硬盘也会影响系统速度，因为系统从硬盘中读取数据并通过总线存入内存的速度也会影响系统运行速度的快慢

##### 5.2.14 CPU 内部结构

[CPU 基础知识-CPU 的组成 运算器、控制器、寄存器 - 流了个火 - 博客园](https://www.cnblogs.com/gnivor/p/15679241.html)

- 运算器：负责算术和逻辑运算 -> ALU
- 控制器：控制部分 -> CU
- 寄存器：暂存指令、数据和地址
- 中断系统

# 六、微控制器相关(单片机)

### 6.1 ARM、DSP 和 FPGA 简析

[ARM、DSP、FPGA 比较——非常详细深入-CSDN 博客](https://blog.csdn.net/xingmeng416/article/details/108671850)
[第 5 章 计算机组成原理和结构 | 计算机体系结构基础](https://foxsen.github.io/archbase/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%92%8C%E7%BB%93%E6%9E%84.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%92%8C%E7%BB%93%E6%9E%84)

##### 6.1.1 指令集与系统架构

- 指令集
  - 复杂指令集(Complex Instruction Set Computer)：Intel、IBM
  - 精简指令集(Reduced Instruction Set Computer)：ARM、AMD
- 系统架构
  - 哈佛：指令和数据分开存储，独立编码，提高数据调用效率 -> 嵌入式使用(哈佛架构是冯·诺依曼架构的变种，并非独立的新型结构)
  - 冯·诺依曼：指令和数据共同存储编码，节省总线 -> 现代计算机使用

##### 6.1.2 ARM(Advanced RISC Machines)

- 面向低端市场的 RISC 微处理器，基本是 32 位单片机的行业标准，它提供一系列内核、体系扩展、微处理器和系统芯片方案，四个功能模块可供生产厂商根据不同用户的要求来配置生产
- RISC 指令集根据 80%的时候只用到了 20%的处理器指令的状况，使用了经过精简设计的指令系统，使得整个 ARM 处理器的设计可以更加简洁，功耗、体积大大缩小，所以 ARM 在目前的手机、平板等智能移动设备上得到了广泛应用

##### 6.1.3 DSP(Digital Signal Processor)

- DSP 是数字信号处理器，只负责处理数字信号；最大特点是内部有专用的硬件乘法器和哈佛总线结构对大量的数字信号处理速度快
- DSP 采用的是哈佛设计，即数据总线和地址总线分开，使程序和数据分别存储在两个分开的空间，允许取指令和执行指令完全重叠。也就是说在执行上一条指令的同时就可取出下一条指令，并进行译码，大大提高了微处理器的速度

##### 6.1.4 FPGA(Filed Programmable Gate Array)

FPGA (现场可编程门阵列)相比于传统的 ASIC（Application Specific Integrated Circuit）的优点之一就是设计周期短，能够迅速迭代和调整设计；同时相较于 CPLD（Complex Programmable Logic Device）复杂可编程逻辑器件，FPGA 的硬件资源更丰富，可以实现更为复杂的逻辑结构

##### 6.1.5 ARM、DSP 和 FPGA 区别

- ARM 优势主要体现在控制方面
- DSP 主要是用来进行计算的，具有强大的数据处理能力和较高的运行速度 -> 通用信号处理器，软件实现数据处理
- FPGA 能够进行编程、除错、再编程和重复操作，因此可以充分地进行设计开发和验证 -> 并行执行，硬件实现数据处理

### 6.2 波特率相关

[波特率是什么，让你详细了解](https://zhuanlan.zhihu.com/p/587556562)

##### 6.2.1 什么是波特率

- 波特率：每秒钟可以传输的符号/码元数，单位为波特，它是衡量串行数据传输快慢的重要指标
- 比特率：波特率\*符号负载的 bit 数

##### 6.2.2 数据传输波特率选择

- 串口传输时，由于没有时钟线，因此相互通信的两个设备必须保持步调一致才能正确解析传输的数据，也即双方波特率等信息相同时才能正确传输数据
- 波特率越高，数据传输速度越快，但有效通信距离变短 -> 9600 传输长度一般为 10 米，最大不超过 20 米，115200 一般距离不超过 5 米，通常为 2~3 米内

### 6.3 ROM 和 RAM

[RAM 和 ROM 的区别-CSDN 博客](https://blog.csdn.net/wildand/article/details/91126833)
[初识 flash 芯片----写之前为什么要先擦除-CSDN 博客](https://blog.csdn.net/frank_jb/article/details/123781097)

##### 6.3.1 ROM(只读存储器)

- 断电后数据不会丢失，数据可以长时间断电保存，但不能被修改
- 比如电脑里储存 BIOS 的只读存储器(电脑硬盘可以读写且能长时间断电保存 -> 硬盘不是 ROM)

##### 6.3.2 RAM(随机存取存储器)

- 断电后数据丢失，数据无法在断电后保存
- 比如电脑里的内存条

### 6.4 I/O 口工作方式(GPIO)

详见[GPIO 的八大模式](GPIO的八大模式.md)

### 6.5 扇区、块、页和簇的概念

详见[扇区、块、页和簇](扇区、块、页和簇.md)

- 扇区：物理机械硬盘上真实存在的，磁盘读写的基本单位
- 块/簇：操作系统读写文件的基本单位，可配置大小为$2^n \times 扇区大小$
- 页：操作系统操作内存的基本单位

### 6.6 CPU 读写内存时，CPU、Cache 和 MMU 如何协同工作

[【机试题】2014 大疆嵌入式笔试题（附超详细解答，下篇）-CSDN 博客](https://blog.csdn.net/qq_38410730/article/details/80905551)
[处理器在读内存的过程中，CPU 核、cache、MMU 如何协同工作?-腾讯内容开放平台](https://page.om.qq.com/page/OWgskMDih9NQVv_MnNq72KPg0)
[嵌入式 100 题（86）：简述处理器在读内存的过程中，CPU 核、cache、MMU 如何协同工作？画出 CPU 核、cache、MMU、内存之间的关系示意图加以说明...-CSDN 博客](https://blog.csdn.net/SWK_dy/article/details/114199479)

- CPU 通过地址来访问内存中的单元，如果 CPU 没有 MMU，或者有 MMU 但没有启动，那么 CPU 内核在取指令或者访问内存时发出的地址（此时必须是物理地址，假如是虚拟地址，那么当前的动作无效）将直接传到 CPU 芯片的外部地址引脚上，直接被内存芯片（物理内存）接收，这时候的地址就是物理地址
- 如果 CPU 启用了 MMU（一般是在 bootloader 中的 eboot 阶段的进入 main()函数的时候启用），CPU 内核发出的地址将被 MMU 截获，这时候从 CPU 到 MMU 的地址称为虚拟地址，而 MMU 将这个 VA 翻译成为 PA 发到 CPU 芯片的外部地址引脚上，也就是将 VA 映射到 PA 中(**MMU 将 VA 映射到 PA 是以页（page）为单位的，对于 32 位的 CPU，通常一页为 4k**)

### 6.7 详细说明总线接口 UART、I2C、SPI 和 USB 的异同点

详见：
[嵌入式 I2C、SPI、UART 和 USB 通信协议](嵌入式I2C、SPI、UART和USB通信协议.md)
[嵌入式 100 题（87）：请说明总线接口 USRT、I2C、USB 的异同点（串/并、速度、全/半双工、总线拓扑等）...-CSDN 博客](https://blog.csdn.net/SWK_dy/article/details/114199481)

- UART：通用异步接收/发送，一发一收两条线，通信协议简单，全双工
- I2C：一收一发两条线再加上电路线和 GND 线，可同时接入多个 I2C 设备，半双工
- SPI：高速同步串行口，3 或 4 条线，可同时接入多个 SPI 设备，全双工
- USB：通用串行总线，4 条线(两条数据线 D+和 D-) -> 差分传输(CAN、RS485)，需要两条数据线一起才能传输一个 bit，可接入多个 USB 设备，半双工

### 6.8 异步串口和同步串口

[串口通信的同步与异步的理解与实现 - frankuly - 博客园](https://www.cnblogs.com/frankuly/p/13785424.html)
[串口通信基础（一）——串行与并行通信，同步与异步通信](https://blog.csdn.net/sym_robot/article/details/113182977)

> 串口通信：按照比特位进行发送和接收数据的通信方式，其中最重要的参数为波特率、数据位、停止位和奇偶校验位
> 异步通信与同步通信的区别在于==通信双方是否共用同一个时钟==

##### 6.8.1 异步串口

- 采用固定通信格式，数据以相同帧格式发送，每帧数据由起始位、数据位、奇偶校验位和停止位组成
- 无需进行时钟同步，而是通过**帧数据中的起始位进行同步(自同步)**

##### 6.8.2 同步串口

- 数据开始传输前使用同步字符来指示并由时钟实现收发端之间的同步，即检测到规定的同步字符后，就连续按顺序传输数据，直到数据传输完毕
- 同步传送时，字符之间没有间隙，也不要起始位和停止位，仅在数据开始时用同步字符 SYNC 来指示
- 采用**共用外部时钟进行同步(外同步)**
