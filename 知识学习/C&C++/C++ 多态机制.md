# 一、多态性

- 多态性允许基类的指针或引用在运行时指向派生类的对象，并且根据对象的实际类型来调用相应的成员函数
- 采用虚函数实现多态性，当一个基类的成员函数被声明为虚函数时，派生类可以通过覆盖（重写）这个函数来提供自己的实现。在运行调用该虚函数的时候，实际上调用的是指向对象实际类型的虚函数

- 多态性的两种方式

  - 静态多态：函数重载和模板实现(函数名相同但参数类型和数量不同) --> 编译时确定
  - 动态多态：虚函数和继承实现(函数名相同且参数也相同，virtual) --> 运行时确定

- 实现多态的常见方式：使用**指向派生类对象的父类指针(或引用)**调用相应派生类的成员函数 ->动态多态
- 派生类对象可以调用本身的虚函数，但无法调用继承类的虚函数
- 虚函数中定义默认形参时，那么调用该虚函数时默认实参值是**静态赋值**的，因此，如果虚函数的基类版本有默认值，那么对于动态解析的函数调用，会忽略派生类中指定的默认值，总是接受基类的默认形参值

### 1.1 静态多态

> 在静态多态中，编译器在编译时根据函数的签名（函数名和参数列表，不包括返回参数）来确定调用哪个版本的函数
>
> - 优点：编译时完成，性能更高
> - 缺点：若存在大量重载或模板则会导致代码量增加和可读性降低

##### 1.函数重载

允许在同一作用域内声明多个函数，它们具有相同的名称但参数形参列表不同。在调用函数时，编译器根据**传递参数的数量、类型和顺序**来选择匹配的函数

```cpp
#include <iostream>

// 函数重载示例
void print(int x) {
    std::cout << "Integer: " << x << std::endl;
}

void print(double x) {
    std::cout << "Double: " << x << std::endl;
}

int main() {
    print(5);       // 调用第一个 print 函数
    print(3.14);    // 调用第二个 print 函数
    return 0;
}
```

##### 2.模板

通用编程技术，允许编写与特定类型无关的代码。通过使用模板，可以在不同类型的参数上执行相同的操作，而无需为每种类型编写不同函数

```cpp
#include <iostream>

// 模板示例
template <typename T>
void print(T x) {
    std::cout << "Value: " << x << std::endl;
}

int main() {
    print(5);// 实例化一个 int 类型的 print 函数
    print(3.14);// 实例化一个 double 类型的 print 函数
    print("Hello");// 实例化一个 const char* 类型的 print 函数
    return 0;
}
```

### 1.2 动态多态

> - 在程序运行时根据对象实际类型来决定调用哪个版本的函数。动态多态通过**虚函数和继承**来实现，编译时无法确定函数调用的具体版本，而是在运行时根据对象的具体类型动态确定
> - 动态多态的实现需要满足以下两个条件：
>
> 1. 基类中声明虚函数：  在基类中将函数声明为虚函数，这样程序会在运行时进行函数调用的动态绑定
> 2. 派生类重写虚函数：派生类中可以通过重写（覆盖）基类中的虚函数来提供自己的实现。在调用这个虚函数时，会根据对象的实际类型来决定调用哪个版本的函数

```cpp
#include <iostream>

// 基类
class Animal {
public:
    // 虚函数
    virtual void makeSound() {
        std::cout << "Animal makes a sound" << std::endl;
    }
};

// 派生类
class Dog : public Animal {
public:
    // 重写基类的虚函数
    void makeSound() override {
        std::cout << "Dog barks" << std::endl;
    }
};

// 派生类
class Cat : public Animal {
public:
    // 重写基类的虚函数
    void makeSound() override {
        std::cout << "Cat meows" << std::endl;
    }
};

int main() {
    // 创建派生类对象
    Dog dog;
    Cat cat;

    // 基类指针指向派生类对象
    Animal* ptr1 = &dog;
    Animal* ptr2 = &cat;

    // 通过基类指针调用虚函数，实现多态
    ptr1->makeSound(); // 调用的是派生类 Dog 的 makeSound() 函数
    ptr2->makeSound(); // 调用的是派生类 Cat 的 makeSound() 函数

    return 0;
}
```

### 1.3 重载、重写(覆盖)与隐藏

##### 1.3.1 重载(overload)

同一可访问区内声明的具有不同形参的同名函数称为函数重载(返回类型和函数名相同，形参类型、个数和顺序不同)

##### 1.3.2 重写(覆盖)(override)

派生类中重新定义基类相同的函数(函数名、参数列表和返回类型均相同)，基类的函数使用 virtual 修饰

##### 1.3.3 隐藏

派生类的函数屏蔽掉同名的基类函数(只需函数名相同，不管参数列表是否相同)，基类函数没有使用 virtual 修饰

- 若基类函数已经使用 virtual 修饰，那么派生类中定义同名函数(返回值相同，形参不同)不会是虚函数而是属于派生类的成员函数，无法实现多态
- 若基类函数已经使用 virtual 修饰，那么派生类中定义同名函数(只有返回值不同，内建返回值)则会报错"返回类型与重写虚函数返回类型既不相同，也不协变" -> 子类重写父类虚函数时，子类函数的返回值类型可以是父类函数返回值类型的子类指针或者引用类型，语义上要求子类与父类能够构成一种`is-a`关系

##### 1.3.4 三者区别

- 重载和重写/覆盖的区别：

  - 范围区别：**重写**和**被重写**的函数在不同的类中，**重载**和**被重载**的函数在同一类中
  - 参数区别：**重写**与**被重写**的函数参数列表一定相同，**重载**和**被重载**的函数参数列表一定不同
  - virtual 的区别：**重写**函数的基类必须要有 virtual 修饰，**重载**函数和**被重载**函数可以被 virtual 修饰，也可以没有

- 隐藏和重写/覆盖、重载的区别：
  - 与重载范围不同：隐藏函数和被隐藏函数在不同类中
  - 参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是被重写

# 二、多态原理

### 2.1 虚函数表指针

指向虚函数表(本质上是虚函数指针数组，顺序取决于虚函数声明的顺序)的指针，位于对象首部，当类中定义虚函数时，对类对象实例化时添加一个隐藏的虚函数表指针

### 2.2 虚函数表特点

- 虚表在编译期确定
- 虚函数继承体系中，派生类的虚表都是继承自虚基类的虚表
- 若派生类重写基类的虚函数，则派生类中虚表用重写后的虚函数覆盖基类的虚函数；否则派生类虚函数表和基类虚函数表相同
- 若派生类新增虚函数，则按照声明顺序放到派生类虚表末尾 -> 非虚继承的情况下
- 同种类定义的对象共享同一份虚函数表，当派生类对象直接赋值给基类对象后，虚表是原来被赋值的基类(**拷贝只拷贝成员而不会拷贝虚表**) --> 因为若被赋值基类虚表变为派生类的，那么此时虚表中会存在被派生类重写后的虚函数，这是不合理的

### 2.3 虚析构函数

C++实现多态的机制里，析构函数都需要写成虚函数即虚析构函数，原因如下：

- 使用多态特性时，基类指针指向派生类对象时，若析构函数不是虚函数，则通过基类指针销毁派生类对象时只能调用静态绑定基类的析构函数，导致无法调用派生类析构函数，造成资源泄露或其他未定义行为
- 为实现程序可扩展性和健壮性，使用多态特性时，一般建议将基类析构函数定义为虚函数

参考：

- [必知必会之 C++多态机制](https://mp.weixin.qq.com/s/NyS2PJjNaSU4VuWAHMhOOQ)
- [深入剖析 C++多态的实现与原理-详解 - HJfjfK - 博客园](https://www.cnblogs.com/DSCL-ing/p/18240152)
- [2.为什么析构函数一般写成虚函数 - CodeMagicianT - 博客园](https://www.cnblogs.com/codemagiciant/p/17602311.html)
- [# 13.析构函数一般写成虚函数的原因、构造函数为什么一般不定义为虚函数、构造函数或者析构函数中调用虚函数会怎样](https://blog.csdn.net/qq_43365825/article/details/103291277)
- [C++中重载、重写（覆盖）和隐藏的区别实例分析 - fenghuan - 博客园](https://www.cnblogs.com/fenghuan/p/4796039.html)
- [C++虚函数重写——重写带默认参数的函数](https://zhuanlan.zhihu.com/p/224990704)
- [C++基础::语法特性::函数重写（override）与协变返回类型（covariant return type）-CSDN 博客](https://blog.csdn.net/lanchunhui/article/details/49756751)
