[C/C++ 函数调用过程，压栈出栈 - Clovran-Wong - 博客园](https://www.cnblogs.com/wiesslibrary/p/15727311.html)

# 一、栈

见[2.1 栈区(stack) <- 堆栈](<../操作系统/Linux/可执行程序内存分配.md#2.1%20栈区(stack)%20<-%20堆栈>)

内存空间中的栈用于保存函数参数，返回值，返回地址和局部变量等，也包含函数调用过程中的一系列信息

# 二、栈帧(stack frame)

- 本质上是一种栈，但是是专门用来保存函数调用过程中的各种信息(函数实参、返回地址、局部变量等)，栈帧有栈顶和栈底之分(栈向下生长，栈顶在下，栈底在上)，栈指针 SP(stack pointer)一直指向栈顶
- X86 系统中，`%ebp`指向栈底，`%esp`指向栈顶(栈指针 SP)

* 一般的，将`%ebp`和`%esp`间区域作为栈帧，每调用一个函数就会生成一个新的栈帧
  ![](https://upload-images.jianshu.io/upload_images/1134295-ce2aa08820b11888.png)

# 三、函数调用过程

### 3.1 函数参数从右到左入栈

[c/c++参数入栈顺序和参数计算顺序 - 肆空界 - 博客园](https://www.cnblogs.com/Zhaolongtao/p/17633979.html)

> 为什么 C/C++的函数参数是从右到左入栈？

主要是支持动态参数
> 函数参数个数可以 **动态变化**，使用**函数参数长度可变**的特性时更加方便

通过栈堆分析可知，自左向右的入栈方式，最前面的参数被压在栈底。这样的话，除非知道参数个数，否则是无法通过栈指针的相对位移求得最左边的参数，就变成了左边参数的个数不确定，正好和动态参数个数的方向相反

例如：
printf("%f %d %d", 1.0,2,3)采用从右到左入栈顺序时(3,2,1.0,"%d %d %f")，参数出栈时顺序为"%f %d %d", 1.0,2,3；如果采用从左向右入栈顺序时("%f %d %d", 1.0,2,3)，参数出栈顺序为 3,2,1.0,"%d %d %f"

### 3.2 三类函数的调用过程

详见[C++成员函数及其调用](C++成员函数及其调用.md)

##### 3.2.1 普通函数

- 开辟栈帧空间
- 函数参数从右向左入栈
- 函数返回地址入栈
- 函数局部变量入栈

##### 3.2.2 普通成员函数调用流程

- 由于函数地址在编译期间就已经确定，因此直接找到该函数地址
- 将 this 指针作为隐含参数传入该成员函数
- 后续调用与普通函数调用相同

##### 3.2.3 虚函数调用流程

- 查找 this 指针地址
- 根据 this 指针查找虚函数表指针指向的虚函数表的地址
- 从虚函数表中找到对应函数地址
- 传入 this 指针
- 后续调用与普通函数调用相同
