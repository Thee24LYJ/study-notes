- [C++ 继承 | 菜鸟教程](https://www.runoob.com/cplusplus/cpp-inheritance.html)
- [C++普通继承和虚继承详解-CSDN 博客](https://blog.csdn.net/m1059247324/article/details/106607191)
- [C++虚继承原理与类布局分析 - 千松 - 博客园](https://www.cnblogs.com/ThousandPine/p/18111381)
- [类对象内存布局](类对象内存布局.md)
- [C++ 多态机制](C++%20多态机制.md)

> - 继承就是一个派生类/子类继承了另一个基类/父类的属性和方法
> - 通过继承，派生类拥有基类所有属性和方法(除构造函数/拷贝构造函数/析构函数/重载运算符/友元函数)，且能添加自己的属性和方法，某些情况下可以使用派生类对象作为基类对象使用

# 一、普通继承

### 1.1 继承特点

- 继承表示的是`is a`关系，例如哺乳动物是动物，猫是哺乳动物，所以猫是动物
- 继承方式为：public、protected 和 private
- 基类中的 private 成员虽然对派生类不可见，但实际上它还是被继承到了派生类中，只是语法上无法访问
- 当基类成员不想在类外被直接访问，但是派生类要能访问，此时该基类成员访问权限需要设为 protected
- 友元关系不能被继承，即类 A 是 类 B 的友元，类 C 是类 A 的派生类，但类 C 不是类 B 的友元
- 基类中的 static 成员在整个继承体系中都只会存在一个 static 成员实例

| 基类不同访问权限成员 | public 继承得到的成员访问权限 | protected 继承得到的成员访问权限 | private 继承得到的成员访问权限 |
| :------------------: | :---------------------------: | :------------------------------: | :----------------------------: |
|        public        |            public             |            protected             |            private             |
|      protected       |           protected           |            protected             |            private             |
|       private        |         派生类不可见          |           派生类不可见           |          派生类不可见          |

### 1.2 继承分类

##### 1.2.1 单继承

```cpp
class 派生类类名 : 继承方式 基类名
{
	// 成员变量和成员函数声明
};

// 示例
class A
{
};

class B : public A
{
};
```

##### 1.2.2 多继承

```cpp
class 派生类类名 : 继承方式 基类名1, 继承方式 基类名2, ...
{
	// 成员变量和成员函数声明
};

// 示例
class A
{
};

class B
{
};

class C : public A, protected B
{
};
```

- 菱形继承 --> 解决办法：虚继承

```cpp
class person
{
};

class student : public person
{
};

class teacher : public person
{
};

class assistant : public student, public teacher
{
};
```

- 数据冗余问题：assistant 中存在两份 person 成员
- 二义性问题

### 1.3 继承中的细节

##### 1.3.1 继承作用域

- 基类和派生类成员作用域相互独立
- 基类和派生类存在同名成员(变量和函数)，派生类将会隐藏基类的成员(类似于局部同名变量会隐藏对应的全局变量)，可以使用`基类名::基类成员`来强制访问基类成员

##### 1.3.2 派生类的构造与析构

- 派生类构造函数(拷贝构造函数、operator=)会先调用基类构造函数(拷贝构造函数、operator=)，若**基类不存在默认构造函数则必须在派生类构造函数中显式调用基类构造函数**
- 派生类析构函数调用完成后会自动调用基类析构函数，确保实现基类成员的释放
- 派生类对象构造时，先构造基类部分再构造派生类部分；派生类对象析构时，先析构派生类部分再析构基类部分

# 二、虚继承

- 保留一份重复的基类实例情况下，通过虚基类表(vtable)来访问共享的实例
- 虚继承中，派生类布局起始位置添加一个虚基类指针，用来指向虚基类表
- 虚继承中，基类实例储存于派生类末尾

> 虚继承解决菱形继承中派生类间接拥有多个相同的基类实例的问题
>
> 虚继承产生虚基类，用于在多重继承下保证基类在派生类中拥有唯一实例

```cpp
class B
{
};
// 虚继承
class B1 : virtual public B
{
};
// 虚继承
class B2 : virtual public B
{
};
// 虚拟菱形继承
class C : public B1, public B2
{
};
```

# 三、基类和派生类对象间转换

- 派生类对象可以赋值给基类对象、基类指针和基类引用
- 基类对象无法赋值给派生类对象(可以理解为：派生类对象赋值给基类对象时直接截断派生类对象中的基类部分给对应的基类对象；而基类对象赋值给派生类对象时缺少派生类那部分导致无法赋值)
- 当基类指针是指向派生类对象时，基类指针可以强制转换赋值给对象派生类指针，否则行为未定义(不安全) -> 多态
