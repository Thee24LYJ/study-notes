- [图说 C++对象模型：对象内存布局详解 - melonstreet - 博客园](https://www.cnblogs.com/QG-whz/p/4909359.html)

> 不同编译器在类对象内存布局实现细节上可能有所不同

# 一、C++对象模型

> C++对象模型解释：
>
> - 直接支持面向对象程序设计的部分，包括构造函数、析构函数、多态和虚函数等
> - 对于各种支持的底层实现机制

### 1.1 对象模型概述

- C++中数据成员分为 static 和非 static，成员函数分为 static、非 static 和 virtual 的
- C++中处于同一访问标识符声明的数据成员，在内存中储存的顺序与声明顺序相同

##### 1.1.1 简单对象模型

类对象由一系列指针组成，分别指向数据成员或成员函数(每次读取类对象数据成员或调用类对象成员函数，都需要通过再次寻址找到其实际地址)

##### 1.1.2 表格驱动模型

在简单对象模型基础上添加间接层，将类对象分为**数据成员**和**成员函数**两个部分并使用两张表格存储，一张存储数据成员本身，一张存储成员函数地址，类对象实际只含有两个指针，分别指向上述两个表

##### 1.1.3 非继承下的对象模型

- 对于数据成员，非 static 存放于每个类对象里，static 存放于类对象外
- 对于成员函数：
  - 非 static 和 static 函数都存放于类对象外
  - virtual 函数寻址通过虚函数表和虚指针支持

virtual 函数寻址实现：

- 每个**类**都存在一个虚表(vtbl)，虚表中存放着指向该类每个虚函数的指针，虚表中的虚函数指针按照类中声明虚函数的顺序排列(类中存在多个重载函数时除外)
- 每个**类对象**都拥有一个虚表指针(vptr)，编译器自动生成，虚表指针的设定由类的构造函数、析构函数、赋值操作符实现；vptr 位置由编译器决定，传统上放于所有显式声明的成员后面，目前大多放于类对象最前面(另外，虚表前面设有一个指向 type_info 的指针，用以支持 RTTI（Run Time Type Identification，运行时类型识别）)

##### 1.1.4 继承下的对象模型

###### 1.1.4.1 单继承

- 单继承类层次结构中，基类与派生类起始地址相同，派生类引入的数据附加到基类内存布局末尾
- 对于一般继承，若子类重写（overwrite）父类的虚函数，则子类虚函数将覆盖虚表中对应的父类虚函数(**子类与父类拥有各自的一个虚函数表**)；若子类并未 overwrite 父类虚函数，而是声明了新的虚函数，则该虚函数地址将扩充到虚函数表最后(子类会扩展父类的虚函数表)
- 对于虚继承，若子类 overwrite 父类虚函数，同样地子类将覆盖父类的虚函数表中虚函数的对应位置，而若子类声明了自己新的虚函数，则编译器将为子类增加一个新的虚表指针 vptr

###### 1.1.4.2 多继承

- **非菱形继承**
  - 第一个基类与派生类起始地址相同，其他基类与派生类起始地址存在偏移量
  - 派生类虚函数放在第一个基类的虚函数表中
  - 派生类重写虚函数时，所有基类对应的虚函数都被派生类虚函数覆盖
  - 派生类对象内存布局中，基类按照声明的顺序排列
- **菱形继承**
  - 基类被派生类简单重复继承了多次，因此派生类对象中存在多份基类实例，导致空间浪费和语法二义性问题
  - 解决空间浪费和语法二义性办法：**虚继承**

### 1.2 C++封装

##### 1.2.1 封装的布局成本

- 普通类：封装没有带来任何空间或执行期的效率影响
- 特殊：**带有虚函数的类**或**虚继承**会导致封装出现额外的成本

##### 1.2.2 空类

- 编译器为空类分配 1 字节的空间，让空类的实例对象能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址
- 当该空类作为基类时，该类的大小就优化为 0 了，这就是所谓的空白基类最优化

# 二、虚继承内存布局

- 采用虚继承的派生类，若定义了新的虚函数，编译器会为该派生类生成一个虚函数指针(vptr)以及一张虚函数表(非虚继承的派生类中定义的虚函数直接在基类虚函数表中扩展)
- 采用虚继承的派生类，仍然单独保留了基类的虚函数指针与虚函数表
- 采用虚继承的派生类对象中，包含四个字节的虚表指针偏移量
