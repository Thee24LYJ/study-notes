- [构造函数与成员初始化器列表 - C++中文 - API 参考文档](https://www.apiref.com/cpp-zh/cpp/language/initializer_list.html)
- [析构函数 - C++中文 - API 参考文档](https://www.apiref.com/cpp-zh/cpp/language/destructor.html)
- [C++ 类构造函数 & 析构函数 | 菜鸟教程](https://www.runoob.com/cplusplus/cpp-constructor-destructor.html)
- [C++ 构造函数实战指南：默认构造、带参数构造、拷贝构造与移动构造 - 小万哥丶 - 博客园](https://www.cnblogs.com/xiaowange/p/18151512)
- [C++中的五种构造函数-CSDN 博客](https://blog.csdn.net/TABE_/article/details/116714304)
- [C++构造函数、析构函数与抛出异常 - hellogiser - 博客园](https://www.cnblogs.com/hellogiser/p/constructor-destructor-exceptions.html)
- [C++学习之构造函数中的异常处理 - 神奕 - 博客园](https://www.cnblogs.com/songlee/p/5738092.html)

# 一、构造函数(Constructor)

- 构造函数是特殊的非静态成员函数，用于初始化该类类型的对象
- 构造函数中抛出异常是C++中通知对象构造失败的**唯一方法**

```cpp
class A
{
public:
	// 构造函数
	A(){}  // 默认构造函数
	// 普通构造函数
	A(int a){a = _a;}  // 直接初始化
	A(int b) : _b(b) {}  // 列表初始化
	// 拷贝构造函数
	A(const A& other) {}
	// 移动构造函数
	A(A&& other) {}
	// 析构函数
	~A(){}
private:
	int _a;
	int  _b;
};
```

- 构造函数可以抛出异常，但抛出异常后该对象析构函数不会被执行 -> 该对象部分构造无法调用析构函数/抛出异常后程序执行控制权会被转移
- (无论何时，从构造函数中抛出异常都是可以的)(new 运算符保证不会出现内存泄漏，有异常处理机制 -> 即使用new分配内存出错也不会造成内存泄漏)
- 但是若构造函数中抛出异常导致new分配成功的内存未使用delete释放则会造成内存泄漏

### 1.1 默认构造函数

类中没有构造函数时，若满足以下条件之一时，编译器才会自动生成默认构造函数：

- 类中含有非内置类型的成员变量，且该种类型含有默认构造函数
- 类继承自含有默认构造函数的基类
- 类继承或声明了虚函数

### 1.2 带参数的构造函数

类构造函数带有参数，参数可以是内置类型、自定义类型对象和指针等

### 1.3 拷贝构造函数

拷贝构造函数从一个已有对象中创建新对象，用于复制另一个对象而非共享该对象的数据

- 类中没有拷贝构造函数时，若满足以下条件之一时，编译器会自动生成默认的拷贝构造函数(默认拷贝构造函数实现的是浅拷贝)：
  - 类中含有非内置类型的成员变量，且该类型含有拷贝构造函数
  - 类继承自含有拷贝构造函数的基类
  - 类继承或声明了虚函数
- 拷贝构造函数调用时机：
  - 使用一个对象去初始化另一个对象时(`A a2(a1);`和`A a2 = a1;`)
  - 函数形参为类对象，采用拷贝构造函数初始化(`void func(A a); A a; func(a);`)
  - 函数返回值为类对象时，采用拷贝构造函数初始化

### 1.4 移动构造函数

移动构造函数从即将销毁的临时对象转移数据到新对象，用于避免不必要的数据复制，提高性能

# 二、析构函数(Destructor)

- 析构函数时对象生存期结束时调用的特殊成员函数，目的是释放对象可能在生存期间获得的资源

```cpp
class A
{
public:
	// 构造函数
	A(){}
	A(int a){a = _a;}
	// 析构函数
	~A(){}
private:
	int _a;
};
```

- 析构函数不推荐抛出异常(析构函数抛出异常则要求必须在析构函数内处理所有异常或结束程序)
