# 一、假设两个服务端 A、B。 A 提供转码服务，B 来调用 A，转码平均时间是 10h。你觉得是同步还是异步来显示结果好？具体该如何实现？

1. **使用回调函数**：调用转码服务时，可以提供一个回调函数，当转码完成后执行该回调函数，返回结果。
2. **使用事件发布/订阅模式**：在转码完成事件触发后，发送事件通知服务端 B。
3. **使用 WebSocket 或 Server-Sent Events (SSE)**：通过 WebSocket 或 SSE 技术，A 可以在转码完成后实时通知 B。

# 二、零拷贝

[彻底理解零拷贝，看这一篇就够了-CSDN 博客](https://blog.csdn.net/huhigher/article/details/134908031)

零拷贝的理想状态就是操作数据不用拷贝，但是显示情况下并不一定真的就是一次复制操作都没有，而是尽量减少拷贝操作的次数 -> 减少 CPU 的处理负载，提高数据传输效率

如何实现零拷贝：

- 尽量减少数据在各个存储区域的复制操作，例如从磁盘缓冲区到内核缓冲区等
- 尽量减少用户态和内核态的切换次数及上下文切换
- 使用一些优化手段，例如对需要操作的数据先缓存起来，内核中的 PageCache 就是这个作用

具体的零拷贝方案：

- DMA
- sendfile
- 共享内存(应用程序和内核直接读写数据)
- 内存映射文件(对内存映射区的修改直接反映到实际文件中)

# 三、std::endl 和'\n'区别

- `std::endl`会在输出流中插入一个换行符，然后刷新输出缓冲区
- `\n`仅仅只插入一个换行符，而不会触发缓冲区刷新，可以手动调佣`std::cout.flush()`刷新缓冲区
