[浅析 Linux 内核同步机制-CSDN 博客](https://blog.csdn.net/fzubbsc/article/details/37736683?utm_source=tuicool&utm_medium=referral)
[Linux 内核同步方式总结-CSDN 博客](https://blog.csdn.net/yyf_it/article/details/52416994)

# 一、Linux 为什么需要同步机制

### 1.1 互斥与同步

> 互斥和同步都是用来控制进程对特定资源访问的机制

- 互斥：控制某些系统资源任意时刻只能允许一个进程访问的机制(互斥是同步的特殊情况)
- 同步：控制多个进程按照一定规则或顺序访问某些系统资源的机制

### 1.2 Linux 为什么需要同步机制？

Linux 系统中各个进程间存在资源竞争和共享，同时由于中断、异常机制导致内核态抢占进程的正常执行，对于这些交错路径执行的进程，如不采取必要的同步措施，将会对一些关键数据结构进行交错访问和修改，导致这些数据结构状态的不一致，进而导致系统崩溃。因此，**为了确保系统高效稳定有序地运行，linux 必须要采用同步机制**

# 二、Linux 内核同步机制

> 临界区：对共享资源进行访问的代码片段
> 临界资源：各进程采取互斥的方式，实现共享的资源
> 并发源：导致出现多个进程对同一共享资源进行访问的原因

### 2.1 禁用中断

> 针对单处理器不可抢占系统，对于单处理器不可抢占系统来说，系统并发源主要是中断处理。因此在进行临界资源访问时，禁用/使能中断就能达到消除异步并发源的目的

### 2.2 自旋锁

> 在多处理器系统中提供对共享数据的保护

##### 2.2.1 自旋锁设计思想

在多处理器之间设置一个全局变量 V 表示锁。并定义当 V=1 时为锁定状态，V=0 时为解锁状态。自旋锁同步机制是针对多处理器设计的，属于**忙等待机制**。自旋锁机制只允许唯一的一个执行路径持有自旋锁。如果处理器 A 上的代码要进入临界区，就先读取 V 的值。如果 V!=0 说明是锁定状态，表明有其他处理器的代码正在对共享数据进行访问，那么此时处理器 A 进入忙等状态（自旋）；如果 V=0，表明当前没有其他处理器上的代码进入临界区，此时处理器 A 可以访问该临界资源。然后把 V 设置为 1，再进入临界区，访问完毕后离开临界区时将 V 设置为 0

注意：必须要确保处理器 A“读取 V,判断 V 的值与更新 V”这一操作是一个原子操作。所谓的原子操作是指，一旦开始执行，就不可中断直至执行结束 -> 要么该操作完全执行完成，要么该操作完成没有执行，不能一部分操作执行一部分操作未执行
##### 2.2.2 自旋锁分类

- 普通自旋锁：多个进程进入临界区时，对临界区中的操作行为不细分，只要是访问共享资源，就执行加锁操作
- 读写自旋锁：允许多个读进程同时进入临界区，交错访问同一个临界资源，提高了系统的并发能力，提升了系统的吞吐量
- 顺序自旋锁：用于解决自旋锁同步机制中，在拥有大量读进程时，写进程由于长时间无法持有锁而被饿死的情况，其主要思想是：为写进程提高更高的优先级，在写锁定请求出现时，立即满足写锁定的请求，无论此时是否有读进程正在访问临界资源。但是新的写锁定请求不会，也不能抢占已有写进程的写锁定

### 2.3 信号量

> 在进程无法获取到临界资源的情况下，立即释放处理器的使用权，并睡眠在所访问的临界资源上对应的等待队列上；在临界资源被释放时，再唤醒阻塞在该临界资源上的进程。另外，**信号量机制不会禁用内核态抢占**，所以持有信号量的进程一样可以被抢占，这意味着信号量机制不会给系统的响应能力、实时能力带来负面的影响

##### 2.3.1 信号量设计思想

除了初始化之外，信号量只能通过两个原子操作 P()和 V()访问，也称为 down()和 up()。down()原子操作通过对信号量的计数器减 1，来请求获得一个信号量。如果操作后结果是 0 或者大于 0，获得信号量锁，任务就可以进入临界区。如果操作后结果是负数，任务会放入等待队列，处理器执行其他任务；对临界资源访问完毕后，可以调用原子操作 up()来释放信号量，该操作会增加信号量的计数器。如果该信号量上的等待队列不为空，则唤醒阻塞在该信号量上的进程

##### 2.3.2 信号量分类

- 普通信号量
- 读写信号量
- 互斥信号量

### 2.4 互斥锁

Linux 内核针对 **count=1 的信号量**重新定义了一个新的数据结构 struct mutex,一般称为互斥锁。内核根据使用场景的不同，把用于信号量的 down 和 up 操作在 struct mutex 上做了优化与扩展，专门用于这种新的数据类型

### 2.5 RCU -> Read-Copy-Update(读/写-复制-更新)

RCU 与前面讨论过的读写自旋锁 rwlock，读写信号量 rwsem，顺序锁一样，它也适用于读取者、写入者共存的系统。但是不同的是，RCU 中的读取和写入操作无须考虑两者之间的互斥问题。但是写入者之间的互斥还是要考虑的

将读取者和写入者要访问的共享数据放在一个指针 p 中，读取者通过 p 来访问其中的数据，而读取者则通过修改 p 来更新数据。要实现免锁，读写双方必须遵守一定的规则

### 2.6 完成接口

用来在多个执行路径间作同步使用，也即协调多个执行路径的执行顺序

### 2.7 per-cpu 变量

将内核变量声明为 per-cpu 变量，它的数据结构是数组，系统的每个 CPU 对应数组中的一个元素，一个 CPU 只能修改自己对应的元素，不用担心竞争条件。per-cpu 只能对来自不同 CPU 的并发访问提供保护，但对自身的异步函数（中断处理函数和可延迟函数）的访问不提供保护，需要同步原语

### 2.8 原子操作

操作在芯片级是原子的，原子操作必须以单个指令执行，中间不能中断，且避免其他的 CPU 访问同一存储器单元
