- [深度：一文看懂 Linux 内核！Linux 内核架构和工作原理详解](https://mp.weixin.qq.com/s/pOODjl0CTZ2hnaCEJNQAGQ)
- [30 分钟看懂！Linux 的内核结构详述](https://zhuanlan.zhihu.com/p/540631415)
- [Linux 内核空间与用户空间 - sparkdev - 博客园](https://www.cnblogs.com/sparkdev/p/8410350.html)
- [Linux 用户态/内核态通信方式汇总 - 付时凡 - 博客园](https://www.cnblogs.com/adam-ma/p/18084237)
- [内核与用户层通信之四种方法](https://blog.csdn.net/vertor11/article/details/79622694)
- [linux 内核剖析（六）Linux 系统调用详解（实现机制分析）](https://www.cnblogs.com/alantu2018/p/8991310.html)
- [用户态和内核态的区别 - Gizing - 博客园](https://www.cnblogs.com/gizing/p/10925286.html)
- [什么是系统调用机制？结合Linux0.12源码图解](https://mp.weixin.qq.com/s/GtBjfwbWr9gXc-fgxg7f5w)

# 一、Linux 内核

### 1.1 Linux 内核任务

- 从技术层面来说：内核是硬件与软件间的中间层，作用是将应用程序请求传递给硬件并充当底层驱动程序，对系统各种设备进行寻址
- 从应用程序层面来说：应用程序只与内核有联系
- 内核是一个资源管理程序，负责将可用的共享资源分配给各个进程
- 内核类似于一个库，提供一组面向系统的命令，系统调用对于应用程序来说就是调用普通函数

### 1.2 Linux 内核策略

> 内核实现策略分为宏内核和微内核，Linux 采用的是宏内核策略

### 1.3 内核态与用户态区别

- 程序运行在特权级 0(Ring0)时称之为运行在内核态，拥有操作系统最高权限，能控制所有硬件资源、访问任意内存地址；程序运行在特权级 3(ring3)时称之为运行在用户态，没有对硬件的直接控制权限，不能直接访问内存地址(特权级也即权限是指能够使用多少 CPU 指令集，能使用越多 CPU 指令集则特权级越高)
- 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序，而大部分用户接触的程序都运行在用户态
- 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其占有的处理器是可被抢占的；处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的
- 在用户态和内核态运行的进程使用的栈是不同的，分别叫做**用户栈和内核栈**， 两者各自负责相应特权级别状态下的函数调用；所以当执行系统调用中断`int 0x80`从用户态进入内核态时，会**从用户栈切换到内核栈**，系统调用返回时，还要切换回用户栈，继续完成用户态下的函数调用(这也叫做被中断进程上下文的保存与恢复)

# 二、Linux 内核整体架构

> Linux 内核作用是将应用程序请求传递给硬件并充当底层驱动程序，对系统中各种设备和组件进行寻址 --> 向上提供系统调用接口，向下管理系统所有硬件设备
> Linux 是一个动态内核，支持动态可加载内核模块

Linux 内核按照核心功能主要分为以下五个部分：

- Process Scheduler(进程管理)
- Memory Manager(内存管理)
- Virtual File System(VFS,虚拟文件系统)
- Network(网络子系统)
- Inter-Process Communication(IPC,进程间通信)

### 2.1 进程管理

- 进程管理重点是进程的执行，还包括处理活动进程间共享 CPU 的需求`(O(1)`调度器)
- 用户空间中称进程，内核空间中称为线程，代表了单独的处理器虚拟化（线程代码、数据、堆栈和 CPU 寄存器）

### 2.2 内存管理

- 管理可用内存的方式、物理和虚拟映射所使用的硬件机制(MMU)
- 可用内存耗光，将内存页面移到硬盘中(交换，swap)

### 2.3 虚拟文件系统

- VFS 为文件系统提供了通用的接口抽象，在 SCI(系统调用接口)和内核所支持文件系统间提供一个交换层

### 2.4 网络子系统

- 负责管理各种网络设备，并实现各种网络协议栈，最终实现通过网络连接其它系统的功能

### 2.5 进程间通信

- 不管理任何硬件，主要负责 Linux 系统进程间的通信

# 三、用户空间与内核通信

[1.4 进程空间分布](进程与线程.md#1.4%20进程空间分布)

> 对于 32 位系统，应用程序占用虚拟空间的 3GB，最高 1GB 的内核被所有应用程序所共用
>
> 为什么划分用户空间和内核空间？
>
> - 将 CPU 指令划分为特权指令和非特权指令，只允许操作系统使用危险的特权指令，普通应用程序只能使用不会造成系统崩溃的非特权指令，降低系统崩溃概率
> - 本质上是提高操作系统稳定性和可用性
>
> - 对于 Intel 的 CPU，特权等级分为 Ring0 到 Ring3，Linux 系统只使用 Ring0(内核态)和 Ring3(用户态)
> - 当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态

- 所有系统资源管理都是在内核空间中完成的，应用程序只能调用内核提供的接口来完成
- linux 利用 FS 寄存器来完成`内核数据空间`与`用户数据空间`的数据复制，当进程从中断调用中退出时，寄存器会自动从内核栈弹出，快捷高效
- 用户态进入内核态(通信)的方式：系统调用、中断、信号、共享内存、ioctl、netlink 、procfs 和 sysfs

### 3.1 系统调用(syscall)

- 最常见的方式，用户态程序通过系统调用接口（如 open、read、write、fork 等）请求内核执行特定的动作
- 系统调用是用户态和内核态之间进行交互的桥梁，它允许用户态程序请求内核提供服务
- 一般来说，系统调用都是通过软件中断实现，进程是不能访问内核的(既不能调用内核函数也不能访问内核空间)，通过系统调用，进程可以访问硬件设备和其他操作系统资源

### 3.2 中断(interrupts)

- 包括软中断和硬中断，此时 CPU 会暂停当前执行的用户态代码，切换到内核态来处理中断
- 中断机制允许内核在适当的时候暂停用户态程序的执行，转而处理一些紧急或特殊的情况

### 3.3 异常

当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常

### 3.4 信号(signal)

内核通过信号通知用户态进程发生了某些事件，用户态程序可以注册信号处理函数来响应特定的信号事件。例如，SIGTERM 和 SIGINT 等信号就是用于通知进程终止或中断的信号

### 3.5 共享内存(share memory)

允许多个进程在它们的地址空间中共享一块内存区域，从而实现用户态和内核态之间的高效通信。这种方式避免了频繁的用户态和内核态切换，但也需要处理数据同步和一致性的问题

### 3.6 ioctl()

这是内核较早的一种用户态和内核态的交互方式。用户态程序通过命令的方式调用 ioctl 函数，然后内核态分发到对应驱动处理，最后将处理结果返回到用户态

### 3.7 Netlink

本质上是一种特殊的 socket，用于内核与多种用户进程之间的消息传递系统。netlink 支持内核与用户态之间的双向通信，是一种全双工通信方式

### 3.8 procfs 和 sysfs

procfs 和 sysfs 是特殊的文件系统，用于内核与用户空间之间的信息交互。procfs 提供了内核和进程的各种信息，而 sysfs 则提供了设备和驱动的信息。用户态程序可以通过读取这些文件系统中的文件来获取内核信息，也可以通过写入特定的文件来配置内核或驱动
