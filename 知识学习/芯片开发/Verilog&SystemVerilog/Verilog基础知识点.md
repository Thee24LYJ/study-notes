[Verilog 教程 | 菜鸟教程](https://www.runoob.com/w3cnote/verilog-tutorial.html)

# 一、基础语法

### 1.1 Verilog 数值表示

##### 1.1.1 数值种类

0 -> 逻辑 0 或假 x 或 X -> 未知(信号数值不确定)
1 -> 逻辑 1 或真 z 或 Z -> 高阻态

##### 1.1.2 整数数值表示方法

```
// 指定位宽
4'b1011  // 4bit数据(二进制)
32'h3022_c0de  // 32bit数据(十六进制)
// 不指定位宽 此时根据编译器自动分配位宽，常见的为32bit
counter = 'd100;
counter2 = 100;
// 表示负数
-6'd15
-15
8'sb10111011 // (-69)->10进制 最高位为符号位 使用补码的形式表示
// 1011 1011去掉符号位后表示为59，加上符号位为59-128=-69
```

##### 1.1.3 实数数值表示方法

```
// 非科学计数法
30.123
6.0
0.001
// 科学计数法
1.2e4
1_0001e4
1E-3
```

##### 1.1.4 字符串表示方法

```
// hello world!占12个字节
// 字符串中不能包含回车符
reg [0:12*8-1] str;
initial begin
	str = "hello world!"
end
```

### 1.2 Verilog 数据类型

> Verilog 最常见的数据类型为线网(wire)和寄存器(reg)(无符号)，当位宽大于 1 时，可将这两种类型声明为向量的形式，即多位宽的 wire 和 reg
>
> 有符号整数(integer)：声明时一般不指定位宽，由编译器自动确定
> 实数(real)：实数声明不能带有范围，默认值为 0。如果将一个实数赋值给一个整数，则只有实数的整数部分会赋值给整数
> 时间(time)：保存仿真时间，位宽一般为 64bit，可调用`$time`获取当前仿真时间
> 参数(parameter)：表示常量且只能赋值一次
> Verilog 中可以声明基本数据类型及其向量类型的数组
>
> 连续赋值/门原语赋值或例化语句赋值 -> 定义为 wire
> 过程赋值 -> 定义为 reg
> 对于端口信号来说，input 和 inout 必须定义为 wire 类型，output 既可以定义为 wire 也可以定义为 reg，这取决于如何对其进行赋值(assign 赋值则定义为 wire，always 赋值则定义为 reg)

##### 1.2.1 wire

wire 类型表示硬件单元之间的物理连线，由其连接的器件输出端连续驱动。如果没有驱动元件连接到 wire 型变量，缺省值一般为 "Z"

##### 1.2.2 reg

reg 类型用来表示存储单元，它会保持数据原有的值，直到被改写

```
wire gpio;
reg counter;
wire [31:0] gpio_data; 32bit位宽的寄存器变量data, 最高有效位为31
reg [3:0] counter;
reg [0:31] data;  // 32bit位宽的寄存器变量data, 最高有效位为0
// 这里最高有效位与CPU大小端模式有点像
// reg [3:0] data1;
// reg [0:3] data2;
// 使用 assign data1 = 4'b1101; 存储数据就是 1 1 0 1(从第3位到第0位)
// 使用 assign data2 = 4'b1101; 存储数据就是 1 0 1 1(从第3位到第0位)

parameter data_width = 10'd32;
parameter i = 1, j = 2, k = 3;

// 数组声明
integer flag[7:0];  // 8个整数组成的数组
reg [7:0] counter[3:0];  // 4个8bit组成的数组
wire data_bit[7:0][5:0][255:0][11:0];  // 1bit wire类型的4维数组
```

[Verilog 中 高位与低位-CSDN 博客](https://blog.csdn.net/luoganttcc/article/details/128203365)

Verillog 还支持指定 bit 位后固定位宽的向量域选择访问：

- **[bit+: width]** : 从起始 bit 位开始递增，位宽为 width

* **[bit-: width]** : 从起始 bit 位开始递减，位宽为 width

**对信号重新进行组合成新的向量时，需要借助大括号**

### 1.3 Verilog 表达式

表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。表达式可以在出现数值的任何地方使用

- always 块里赋值对象不能是 wire 型
- 使用算术操作符时如果操作数某一位为 X，则计算结果也会全部出现 X
- 使用关系操作符时如果操作数中有一位为 x 或 z，则关系表达式的结果为 x
- 逻辑相等/不等操作符不能比较 x 或 z，当操作数包含一个 x 或 z，则结果为不确定值。全等比较时，如果按位比较有相同的 x 或 z，返回结果也可以为 1，即全等比较可比较 x 或 z。所以，全等比较的结果一定不包含 x
- Verilog 中提供了大约 9 种操作符，分别是算术、关系、等价、逻辑、按位、归约、移位、拼接、条件操作符
- 逻辑/关系运算结果只可能是 0(逻辑假)、1(逻辑真)和 x(不确定)

| 操作符       | 操作符号           | 优先级 |
| ------------ | ------------------ | ------ |
| 单目运算     | + - ! ~            | 最高   |
| 乘、除、取模 | \* / %             |        |
| 加减         | + -                |        |
| 移位         | <<  >>             |        |
| 关系         | <  <=  >  >=       |        |
| 等价         | ==  !=  \===  !=== |        |
| 归约         | & ~&               |        |
|              | ^ ~^               |        |
|              | \| ~\|             |        |
| 逻辑         | &&                 |        |
|              | \|                 |        |
| 条件         | ?:                 | 最低   |

### 1.4 Verilog 编译指令

以反引号\`开始的某些标识符

```
// 宏定义
`define DATA_DW 32
`undef DATA_DW

// 条件编译
`ifdef MCU
	parameter DATA_DW = 8;
`elsif WINDOWS
	parameter DATA_DW = 64;
`else
	parameter DATA_DW = 32;
`endif

`ifndef MCU
	parameter DATA_DW = 8;
`else
	parameter DATA_DW = 32;
`endif

// 头文件包含
`include "header.v"

// 定义时延、仿真单位和精度
// time_unit：时间单位 time_precision：时间精度
// 时间精度 <= 时间单位
`timescale time_unit / time_precision

// 为隐式线网变量指定为线网类型,即将没有被声明的连线定义为线网类型
`default_nettype wand  // 定义的缺省的线网为线与类型
`default_nettype none  // 该实例定义后将不再自动产生wire型变量

// 将所有的编译指令重新设置为缺省值
`resetall

// 将模块标记为单元模块
`celldefine
`endcelldefine

// 在模块实例化中，出现在这两个编译指令间的任何未连接的输入端口，为正偏电路状态或者为反偏电路状态
`unconnected_drive
`nounconnected_drive
```

### 1.5 Verilog 连续赋值

连续赋值语句是 Verilog 数据流建模的基本语句，用于对 wire 类型变量进行赋值，表示为**电路线路连接**，因此只要与其相连的表达式中操作数值发生变化，那么也会影响到目标变量

```
assign target = expression;
// target必须是标量或线型向量，不能是寄存器类型
// 只要expression表达式操作数值发生变化，其表达式会立刻重新计算并赋值给target
```

```
// 方法1
wire cnt, A, B;
assign cnt = A & B;

// 方法2(等效)
wire A, B;
wire cnt = A & B;
// wire型变量声明时同时赋值，wire型变量只能被赋值一次
```

### 1.6 Verilog 时延

连续赋值延时语句中的延时，用于控制任意操作数发生变化到语句左端赋予新值之间的时间延时，时延一般是不可综合的，连续赋值时延一般可以分为普通赋值时延、隐式时延和声明时延

```
// 普通时延 A&B计算结果延时10个时间单位赋值给Z
wire Z, A, B;
assign #10 Z = A & B;

// 隐式时延，声明一个wire型变量时对其进行包含一定时延的连续赋值。
wire A, B;
wire #10 Z = A & B;

// 声明时延，声明一个wire型变量是指定一个时延。因此对该变量所有的连续赋值都会被推迟到指定的时间。除非门级建模中，一般不推荐使用此类方法建模。
wire A, B;
wire #10 Z ;
assign Z =A & B;
```

惯性时延：在上述例子中，A 或 B 任意一个变量发生变化，那么在 Z 得到新的值之前，会有 10 个时间单位的时延。如果在这 10 个时间单位内，即在 Z 获取新的值之前，A 或 B 任意一个值又发生了变化，那么计算 Z 的新值时会取 A 或 B 当前的新值。所以称之为惯性时延，即信号脉冲宽度小于时延时，对输出没有影响

# 二、Verilog 语句

### 2.1 Verilog 过程结构

包含 initial 和 always 语句(行为级建模的基本语句)
一个模块中可以包含多个 initial 和 always 语句，但 2 种语句不能嵌套使用
这些语句在模块间并行执行，与其在模块的前后顺序没有关系，但是 initial 语句或 always 语句内部可以理解为是顺序执行的（非阻塞赋值除外）
每个 initial 语句或 always 语句都会产生一个独立的控制流，执行时间都是从 0 时刻开始

##### 2.1.1 initial 语句

initial 语句从 0 时刻开始执行，**只执行一次**，多个 initial 块之间是相互独立的
如果 initial 块内包含多个语句，需要使用关键字 begin 和 end 组成一个块语句，如果 initial 块内只要一条语句，关键字 begin 和 end 可使用也可不使用
initial 理论上来讲是不可综合的，多用于初始化、信号检测等

##### 2.1.2 always 语句

always 语句是重复执行的，类似于 C 中的 while(1)语句
由于循环执行的特点，always 语句多用于仿真时钟的产生，信号行为的检测等
always 语句中的赋值目标必须是 reg 类型，连续赋值语句 assign 的赋值目标必须是 wire 类型

### 2.2 Verilog 过程赋值

- 过程性赋值是在 initial 或 always 语句块里的赋值，赋值对象是寄存器、整数、实数等类型，这些变量在被赋值后，其值将保持不变，直到重新被赋予新值，Verilog 过程赋值包括阻塞赋值和非阻塞赋值
- 连续性赋值总是处于激活状态，任何操作数的改变都会影响表达式的结果

##### 2.2.1 阻塞赋值

阻塞赋值属于顺序执行，即==下一条语句执行前，当前语句一定会执行完毕==
阻塞赋值语句使用等号  =  作为赋值符

##### 2.2.2 非阻塞赋值

非阻塞赋值属于并行执行语句，即==下一条语句的执行和当前语句的执行是同时进行的==，它不会阻塞位于同一个语句块中后面语句的执行
非阻塞赋值语句使用小于等于号  <=  作为赋值符
**使用非阻塞赋值避免竞争冒险**

### 2.3 Verilog 时序控制

Verilog 提供了 2 大类时序控制方法：时延控制和事件控制。事件控制主要分为边沿触发事件控制与电平敏感事件控制

##### 2.3.1 时延控制

基于时延的时序控制出现在表达式中，它指定了语句从开始执行到执行完毕之间的时间间隔，时延可以是数字、标识符或者表达式，根据在表达式中的位置差异，时延控制又可以分为常规时延与内嵌时延

- 常规时延
  遇到常规延时时，该语句**需要等待一定时间，然后将当前时刻的计算结果赋值给目标信号** -> 先等待再计算

```
#delay statement
reg a;
reg b;
#10 b = a;
```

- 内嵌时延
  遇到内嵌延时时，该语句**先将计算结果保存，然后等待一定的时间后赋值给目标信号** -> 先计算再等待

```
reg a;
reg b;
b = #10 a;
```

注意：
当延时语句的赋值符号右端是常量时，2 种时延控制都能达到相同的延时赋值效果
当延时语句的赋值符号右端是变量时，2 种时延控制可能会产生不同的延时赋值效果

##### 2.3.2 边沿触发事件控制

Verilog 中事件是指某一个 reg 或 wire 型变量的值发生了变化，事件控制用符号`@`表示，基于事件触发的时序控制又主要分为以下几种：

- 一般事件控制：语句执行条件是信号的值发生特定改变(关键字 posedge 指信号发生边沿正向跳变，negedge 指信号发生负向边沿跳变，未指明跳变方向时，则 2 种情况的边沿变化都会触发相关事件)
- 命名事件控制：自定义 event 类型的变量并触发该变量来识别事件是否发生，命名事件用关键字 event 来声明，触发信号用  `->`  表示
- 敏感列表：当多个信号或事件中任意一个发生变化都能够触发语句的执行时，Verilog 中使用"或"表达式来描述这种情况，用关键字  or  连接多个事件或信号，可以用逗号  ,  来代替 or。这些事件或信号组成的列表称为"敏感列表"

```
// 一般事件控制
always @(clk) q <= d;  // 双边沿触发
always @(posedge clk) q <= d;  // 上升沿触发
always @(negedge clk) q <= d;  // 下降沿触发

// 命名事件控制
event start_receiving;
always @(posedge clk_samp) begin
	-> start_receiving;
end
always @(start_receiving) begin
	q <= d;
end

// 敏感列表
always @(posedge clk or negedge rstn) begin
// always @(posedge clk, negedge rstn) begin // 作用相同
	q <= d;
end
// 组合逻辑输入变量很多时使用@*或@(*)表示对语句块中所有输入变量变化都是敏感的
always @(*) begin
// always @(a,b,c,d,e,f,g,h,i,j) begin
	assign s = a ? b+c : d ? e+f : g ? h+i : j;
end
```

##### 2.3.3 电平敏感事件控制

Verilog 中还支持使用电平作为敏感信号来控制时序，即后面语句的执行需要等待某个条件为真。Verilog 中使用关键字 wait 来表示这种电平敏感情况

```
initial begin
	wait (start_enable);  //等待 start 信号
	forever begin
		//start信号使能后，在clk_samp上升沿，对数据进行整合
		@(posedge clk_samp);
		q <= d;
	end
end
```

### 2.4 Verilog 语句块

Verilog 语句块提供了将两条或更多条语句组成语法结构上相当于一条一句的机制。主要包括两种类型：顺序块和并行块

##### 2.4.1 顺序块

顺序块用关键字 begin 和 end 来表示
顺序块中的语句是一条条执行的。当然，非阻塞赋值除外
顺序块中每条语句的时延总是与其前面语句执行的时间相关

##### 2.4.2 并行块

并行块有关键字 fork 和 join 来表示
并行块中的语句是并行执行的，即便是阻塞形式的赋值
并行块中每条语句的时延都是与块语句开始执行的时间相关

##### 嵌套块

将顺序块和并行块进行嵌套使用

##### 命名块

可以给块语句结构命名，命名的块中可以声明局部变量，通过层次名引用的方法对变量进行访问，使用 disable 可以终止命名块的执行，可以用来从循环中退出、处理错误等
disable 在 always 或 forever 块中使用时是让程序重新从 always 或 forever 块第一句开始执行，此时的 disable 有点类似 C 语言中的 continue

### 2.5 Verilog 条件语句

条件语句使用 if 和 else 声明，条件表达式必须在圆括号中，支持嵌套使用

```
if (condition1)
	true_statement1;
else if (condition2)
	true_statement2;
else if (condition3) begin // 多个执行语句使用begin和end说明
	true_statement3;
	true_statement4;
end
else
	default_statement;
```

### 2.6 Verilog 多路分支语句

case 语句执行时只会执行 condition 为真的语句，支持嵌套使用
当多个条件选项下需要执行相同的语句时，多个条件选项可以用逗号分开，放在同一个语句块的候选项中

```
case (case_expr)
	condition1 : true_statement1;
	condition2 : true_statement2;
	...
	default : default_statement;
endcase
```

casex、 casez 语句是 case 语句的变形，用来表示条件选项中的无关，casex 用 "x" 来表示无关值，casez 用问号 "?" 来表示无关值，两者的实现的功能是完全一致的，语法与 case 语句也完全一致，但是 casex、casez 一般是不可综合的，多用于仿真

### 2.7 Verilog 循环语句

Verilog 循环语句分为 while，for，repeat，和 forever 循环，循环语句只能在 always 或 initial 块中使用，但可以包含延迟表达式

##### 2.7.1 while 循环

```
// while循环
while (condition) begin
	statement;
end

// for循环
for (initial_assignment; condition; step_assignment) begin
	statement;
end

// repeat循环
repeat (loop_times) begin
	statement;
end

// forever循环
forever begin
	statement;
end
```

### 2.8 Verilog 过程连续赋值

过程连续性赋值主要有 2 种，assign-deassign 和 force-release

assign（过程赋值操作）与 deassign （取消过程赋值操作）表示第一类过程连续赋值语句。赋值对象只能是寄存器或寄存器组，而不能是 wire 型变量，赋值过程中对寄存器连续赋值，寄存器中的值被保留直到被重新赋值

force （强制赋值操作）与 release（取消强制赋值）表示第二类过程连续赋值语句。与 assign 和 deassign 不同之处在于赋值对象可以是 reg 和 wire 类型

# 三、Verilog 模块

### 3.1 模块与端口

模块是 Verilog 中基本单元的定义形式，是与外界交互的接口

```
module module_name
#(parameter_list)
(port_list);
	declarations_and_statements;
endmodule
```

![](https://www.runoob.com/wp-content/uploads/2020/09/jxRkciGWpiEbvz3D.png)

端口是模块与外界交互的接口。对于外部环境来说，模块内部是不可见的，对模块的调用只能通过端口连接进行，模块的定义中包含一个可选的端口列表，一般将不带类型、不带位宽的信号变量罗列在模块声明里(位宽隐式为 1 位)

- 端口信号在端口列表中罗列出来以后，就可以在模块实体中进行声明
- Verilog 中，端口隐式的声明为 wire 型变量，即当端口具有 wire 属性时，不用再次声明端口类型为 wire 型。但是，当端口有 reg 属性时，则 reg 声明不可省略
- 还有一种更简洁且常用的方法来声明端口，即在 module 声明时就陈列出端口及其类型。reg 型端口要么在 module 声明时声明，要么在 module 实体中声明

```
// 端口列表
module pad(
	DIN, OEN, PULL,DOUT, PAD
);
endmodule

// 端口声明 (模块实体中声明)
// 端口类型声明
input DIN, OEN;  // 输入端口
input [1:0] PULL;  // 输入端口
inout PAD;  // 双向端口
output DOUT;  // 输出端口

// 端口数据类型声明
wire DIN, OEN;
wire [1:0] PULL;
wire PAD;
reg DOUT;

// 上述端口声明简化
input DIN, OEN;
input [1:0] PULL;
inout PAD;
output DOUT;
reg DOUT;
// DOUT也可以合并
output reg DOUT;
```

### 3.2 模块例化

- 命名端口连接：input 端口无需连接时需悬空，output 端口无需连接时可以悬空或删除
- 顺序端口连接

##### 端口连接规则

**输入端口**
模块例化时，从模块外部来讲， input 端口可以连接 wire 或 reg 型变量。这与模块声明是不同的，从模块内部来讲，input 端口必须是 wire 型变量
**输出端口**
模块例化时，从模块外部来讲，output 端口必须连接 wire 型变量。这与模块声明是不同的，从模块内部来讲，output 端口可以是 wire 或 reg 型变量
**输入输出端口**
模块例化时，从模块外部来讲，inout 端口必须连接 wire 型变量。这与模块声明是相同的

位宽匹配：当例化端口与连续信号位宽不匹配时，端口会通过无符号数的右对齐或截断方式进行匹配
使用 generate 进行多个模块重复例化

### 3.3 带参数例化

##### 3.3.1 defparam 语句

通过模块层次调用方法改写低层次模型参数值，一般不可综合

##### 3.3.2 带参数模块例化(建议使用)

例化模块时，将新的参数值写入模块例化语句，以此来改写原有 module 的参数值

# 四、Verilog 函数、任务和状态机

### 4.1 函数

函数只能在模块中定义，位置任意，并在模块的任何地方引用，作用范围也局限于此模块

函数特点：

- 不含有任何延迟、时序或时序控制逻辑
- 至少有一个输入变量且没有输出，只有一个返回值
- 不含有非阻塞赋值语句
- 函数可以调用其他函数，但是不能调用任务

```
// 函数声明格式
function [range-1:0] function_id;
	input_declaration;
	other_declaration;
	procedural_statement;
endfunction

// 等价函数声明
function [range-1:0] function_id(
	input_declaration;
	...
);
	other_declaration;
	procedural_statement;
endfunction

// 函数调用格式
function_id(input1, input2, ...);
```

##### 4.1.1 常数函数

常数函数是指在仿真开始之前，在编译期间就计算出结果为常数的函数。常数函数不允许访问全局变量或者调用系统函数，但是可以调用另一个常数函数。这种函数能够用来引用复杂的值，因此可用来代替常量

##### 4.1.2 automatic 函数

Verilog 中，一般函数的局部变量是静态的，即函数的每次调用，函数的局部变量都会使用同一个存储空间。若某个函数在两个不同的地方同时并发的调用，那么两个函数调用行为同时对同一块地址进行操作，会导致不确定的函数结果

Verilog 用关键字 automatic 来对函数进行说明，此类函数在调用时是可以自动分配新的内存空间的，也可以理解为是可递归的。因此，automatic 函数中声明的局部变量不能通过层次命名进行访问，但是 automatic 函数本身可以通过层次名进行调用

### 4.2 任务

和函数一样，任务（task）可以用来描述共同的代码段，并在模块内任意位置被调用，让代码更加的直观易读。函数一般用于组合逻辑的各种转换和计算，而任务更像一个过程，不仅能完成函数的功能，还可以包含时序控制逻辑

| 区别     | 函数                                                 | 任务                                                         |
| -------- | ---------------------------------------------------- | ------------------------------------------------------------ |
| 输入     | 函数至少有一个输入，端口声明不能包含 inout 型        | 任务可以没有或者有多个输入，且端口声明可以为 inout 型        |
| 输出     | 函数没有输出                                         | 任务可以没有或者有多个输出                                   |
| 返回值   | 函数至少有一个返回值                                 | 任务没有返回值                                               |
| 仿真时刻 | 函数总在零时刻就开始执行                             | 任务可以在非零时刻执行                                       |
| 时序逻辑 | 函数不能包含任何时序控制逻辑                         | 任务不能出现 always 语句，但可以包含其他时序控制，如延时语句 |
| 调用     | 函数只能调用函数，不能调用任务                       | 任务可以调用函数和任务                                       |
| 书写规范 | 函数不能单独作为一条语句出现，只能放在赋值语言的右端 | 任务可以作为一条单独的语句出现语句块中                       |

模块内子程序出现下面任意一个条件时，则必须使用任务而不能使用函数。

- 子程序中包含时序控制逻辑，例如延迟，事件控制等
- 没有输入变量
- 没有输出或输出端的数量大于 1

```
task task_id;
	port_declaration;
	procedural_statement;
endtask

// 等价任务声明
task task_id(
	port_declaration;
	...
);
	procedural_statement;
endtask
```

任务中使用关键字 input、output 和 inout 对端口进行声明。input 、inout 型端口将变量从任务外部传递到内部，output、inout 型端口将任务执行完毕时的结果传回到外部
进行任务的逻辑设计时，可以把 input 声明的端口变量看做 wire 型，把 output 声明的端口变量看做 reg 型。但是不需要用 reg 对 output 端口再次说明
对 output 信号赋值时也不要用关键字 assign。为避免时序错乱，建议 output 信号采用阻塞赋值

- 任务操作全局变量
  因为任务可以看做是过程性赋值，所以任务的 output 端信号返回时间是在任务中所有语句执行完毕之后
  任务内部变量也只有在任务中可见，如果想具体观察任务中对变量的操作过程，需要将观察的变量声明在模块之内、任务之外，可谓之"全局变量"
- automatic 任务
  和函数一样，Verilog 中任务调用时的局部变量都是静态的。可以用关键字 automatic 来对任务进行声明，那么任务调用时各存储空间就可以动态分配，每个调用的任务都各自独立的对自己独有的地址空间进行操作，而不影响多个相同任务调用时的并发执行

### 4.3 状态机

有限状态机（Finite-State Machine，FSM），简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型
状态机主要用于同步时序逻辑设计，分为 Moore 状态机和 Mealy 状态机

- Moore 型状态机
  该类型状态机输出只与当前状态有关，与当前输入无关
  输出会在一个完整的时钟周期内保持稳定，即使此时输入信号有变化，输出也不会变化。输入对输出的影响要到下一个时钟周期才能反映出来。这也是 Moore 型状态机的一个重要特点：输入与输出是隔离开来的

- Mealy 型状态机
  该类型状态机输出不仅与当前状态有关，还取决于当前输入信号
  Mealy 型状态机的输出是在输入信号变化以后立刻发生变化，且输入变化可能出现在任何状态的时钟周期内。因此，同种逻辑下，Mealy 型状态机输出对输入的响应会比 Moore 型状态机早一个时钟周期

##### 状态机设计：3 段式（推荐）

**状态机设计如下：**

- 首先，根据状态机的个数确定状态机编码。利用编码给状态寄存器赋值，代码可读性更好
- 状态机第一段，时序逻辑，非阻塞赋值，传递寄存器的状态
- 状态机第二段，组合逻辑，阻塞赋值，根据当前状态和当前输入，确定下一个状态机的状态
- 状态机第三代，时序逻辑，非阻塞赋值，因为是 Mealy 型状态机，根据当前状态和当前输入，确定输出信号

修改状态机为 2 段式即将 3 段式状态机 2 和 3 段描述合并即可

### 4.4 竞争与冒险

数字电路中，信号传输与状态变换时都会有一定的延时

##### 4.4.1 产生原因

- 在组合逻辑电路中，不同路径的输入信号变化传输到同一点门级电路时，在时间上有先有后，这种先后所形成的时间差称为竞争（Competition） -> 信号到达先后时间差
- 由于竞争的存在，输出信号需要经过一段时间才能达到期望状态，过渡时间内可能产生瞬间的错误输出，例如尖峰脉冲。这种现象被称为冒险（Hazard）-> 输出信号错误输出
- 竞争不一定有冒险，但冒险一定会有竞争 (先有竞争，后才可能冒险)
- 实际硬件电路中，只要门电路各个输入时延不同，就有可能出现竞争与冒险

##### 4.4.2 判断方法

- 代数法
  逻辑表达式中保持一个变量不变，将其他变量使用 0 或 1 代替，若能化简为`Y=A+A'`或`Y=AA'`的形式则一定存在竞争与冒险

- 卡诺图法

##### 4.4.3 消除竞争冒险的方法

- 增加滤波电容，消除窄脉冲
- 修改逻辑，增加冗余项
- **使用时钟同步电路，利用触发器进行打拍延迟**
- 采用格雷码计数器

避免大多数竞争与冒险问题的 Verilog 书写规划：

- 时序电路建模时，用非阻塞赋值
- 组合逻辑建模时，用阻塞赋值
- 在同一个 always 块中建立时序和组合逻辑模型时，用非阻塞赋值
- 在同一个 always 块中不要既使用阻塞赋值又使用非阻塞赋值
- 不要在多个 always 块中为同一个变量赋值
- 避免 latch 产生 (锁存器)

### 4.5 避免 Latch(锁存器)

##### 4.5.1 什么是 Latch

锁存器（Latch），是电平触发的存储单元，数据存储的动作取决于输入时钟（或者使能）信号的电平值。仅当锁存器处于使能状态时，输出才会随着数据输入发生变化

Latch 的主要危害有：

- 输入状态可能多次变化，容易产生毛刺，增加了下一级电路的不确定性
- 在大部分 FPGA 的资源中，可能需要比触发器更多的资源去实现 Latch 结构
- 锁存器的出现使得静态时序分析变得更加复杂

Latch 多用于门控时钟（clock gating）的控制，一般设计时，我们应当避免 Latch 的产生

##### 4.5.1 Latch 产生的原因

- 组合逻辑中，if 结构不完整
  if 语句中缺少 else 结构，系统默认 else 的分支下寄存器 q 的值保持不变，即具有存储数据的功能，所以寄存器 q 会被综合成 latch 结构，解决办法：==补全 if-else 结构或对信号赋初值==
  时序逻辑中不完整的 if 结构不会产生 Latch
- 组合逻辑中，case 结构不完整
  case 选项列表不全且没有加 default 关键字，或有多个赋值语句不完整时，也会产生 Latch，解决办法：==将 case 选项列表补充完整，或对信号赋初值==
- 原信号赋值或判断
  在组合逻辑中，如果一个信号的赋值源头有其信号本身，或者判断条件中有其信号本身的逻辑，则也会产生 latch。因为此时信号也需要具有存储功能，但是没有时钟驱动。此类问题在 if 语句、case 语句、问号表达式中都可能出现，解决办法：==信号不要给信号自己赋值，且不要用赋值信号本身参与判断条件逻辑==
- 敏感信号列表不完整
  组合逻辑中 always@() 块内敏感列表没有列全，该触发的时候没有触发，那么相关寄存器还是会保存之前的输出结果，因而会生成锁存器，解决办法：==把敏感信号补全或者直接用 always@(\*)==

### 4.6 仿真激励

仿真激励文件(testbench)一般结构：
![](https://www.runoob.com/wp-content/uploads/2020/09/VuJtsmlLrJjDTWDO.png)
其中，最基本的结构包括信号声明、激励和模块例化

### 4.7 流水线

流水线就是解决多周期下串行数据计算效率低的问题
流水线的基本思想是：把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件来实现。将多个处理过程在时间上错开，依次通过各功能段，这样每个子过程就可以与其他子过程并行进行
