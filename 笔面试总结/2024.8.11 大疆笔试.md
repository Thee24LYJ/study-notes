# 一、计算机编程基础

### 1.1 C 语言变量类型自动转换

详见[1.2 隐式转换](../知识学习/C&C++/类型转换.md#1.2%20隐式转换)

函数内定义的变量类型不同，编译器根据变量类型进行数据地址对齐时不会进行数据类型隐式转换，地址对齐更多是为了提高计算效率而采用的

### 1.2 计算机系统中采用补码运算的目的

[【计算机基础】计算机为什么要使用补码？-CSDN 博客](https://blog.csdn.net/lp15929801907/article/details/108807019)
将符号位和数值一并处理，不需要单独的处理符号位，从而降低了复杂度，利用高位溢出，将减法运算变成加法运算，使得加法和减法运算统一处理，简化计算机运算的硬件设计，提高运算效率

### 1.3 Linux(不考虑 rt-patch)内核中断上半部，不允许出现什么操作

[【002 中断】为什么中断要区分上半部和下半部？\_为什么中断要上下半部-CSDN 博客](https://blog.csdn.net/qq_41709234/article/details/130995806)
[Linux 内核中的各种锁：信号量/互斥锁/读写锁/原子锁/自旋锁/内存屏障等-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2389938)

断分成上半部分和下半部分的**原因**主要是**因为内核要保证内核中进程的正常调度和运行，所以中断程序需要短小精悍，但是有些驱动在中断处理程序需要完成大量耗时的工作。**

为了解决这个问题，Linux 将**中断处理程序**分解为两个半部：**上半部（top half）和下半部（bottom half）**。上半部完成**尽可能少的**比较紧急的功能，下半部就由**tasklet 或者工作队列**的方法实现

详见[4.1 锁机制](../知识学习/操作系统/进程与线程.md#4.1%20锁机制)

- `spin_lock(&lock)`：自旋锁，当资源被其他加锁时，自旋锁会一直占用 CPU 检查该资源是否被释放，不会进入睡眠状态
- `write_lock(&rwlock)`：可以采用自旋锁实现读写锁
- `mutex_lock(&mutex)`：互斥锁，与自旋锁不同的是，当资源被加锁占用时，它会进入睡眠状态释放 CPU 资源，直到其他线程唤醒它

由于中断上部不能被(相同类型)中断打断，因此如果在内核中断上半部使用互斥锁进入睡眠后可能无法被唤醒，导致出现一些问题

### 1.4 汇编 DSB 和 ISB

[ARM 基础(6)：内存屏障指令之 DMB、DSB 和 ISB 详解-CSDN 博客](https://blog.csdn.net/tilblackout/article/details/131949061)

- 数据同步屏障(DSB)：执行`DSB`指令时，它确保在`DSB`之前的所有显式数据内存传输指令都已经在内存中读取或写入完成，同时确保任何后续的指令都将在`DSB`执行之后开始执行
- 指令同步屏障(ISB)：处理器会将流水线中的指令全部刷新，从而确保之前的指令不会影响后续指令的执行，并且后续指令将从正确的上下文开始重新获取

### 1.5 X86 架构寄存器内容计算

在 x86 架构处理器并且内存采用小端序存储的情况下，若(DS)=2000H，(BX)=0050H，(20050H)=12H，(20051H)=34H，执行`MOV AX,[BX]`指令后，AX 寄存器中的内容是

执行`MOV AX, [BX]`指令时，将内存地址 DS:BX 指向的地址开始的两个字节，即(20050H)和(20051H)的内容放入到 AX 寄存器中，由于采用小端存储，因此放入 AX 寄存器的值为 0x3412H

### 1.6 Git 中，用于撤销之前的提交并保留更改的命令是`git revert`

见[二、git reset/revert](../知识学习/软件应用/git%20命令.md#二、git%20reset/revert)

### 1.7 组相联映象、 LRU 替换的 Cache 存储器，不影响 Cache 命中率的是增加主存容量

增加 Cache 中的块数、增大组的大小和增大块的大小都会影响 Cache 命中率

### 1.8 Linux

[linux 的调度策略与优先级-CSDN 博客](https://blog.csdn.net/qq_23274715/article/details/110941434)

##### 1.8.1 实时调度策略

`SCHED_RR`,`SCHED_FIFO`调度策略

##### 1.8.2 通用调度策略(分时调度策略)

`SCHED_OTHER`、`SCHED_IDLE`、`SCHED_BATCH`调度策略

##### 1.8.3 Linux 相关

- 用 mv 命令跨文件系统移动文件时，文件的修改时间会发生变化(若不跨文件系统移动文件则文件修改时间一般不会发生变化)
- ulimit -s 设置的是函数调用栈的大小
- 线程非法访问内存时，当前线程会进入信号处理函数
- vmalloc、alloc page、memblock alloc 都是内核底层申请内存的接口
  - `vmalloc`用于分配大的几乎连续的虚拟内存区域
  - `alloc_page`用于分配一个或多个连续的物理页面
  - `memblock_alloc`是`memblock`分配器提供的一个接口，用于分配内存
- 在 Linux 中，buddy system 算法主要用于管理页级别的内存分配，它通过合并相邻的空闲页块来减少内存碎片。而 SLUB(Simple List of Used Blocks)算法是一种用于管理小内存块(通常是页内内存碎片)的分配器，特别适用于内核对象的分配。SLUB 并不管理页外内存碎片，页外内存碎片通常由内存回收机制或更高级别的内存管理策略处理
- Linux 系统中，CFS(完全公平调度)通过每个进程的实际运行时间来衡量哪个进程最值得被调度

### C/C++ 代码题

```cpp
#include <iostream>
using namespace std;

struct foo
{
    uint32_t a;
    int64_t b;
    char c[4];
    uint64_t d[4];
};

// 这里不会执行出错，因为没有对地址内容进行相关读写操作
#define op(v1, v2) ((size_t) & ((v1 *)0)->v2)

int main()
{
    auto a = ((foo *)0); // a起始地址为0并转换为foo结构体指针
    auto c = &((foo *)0)->d; // 取得该结构体中成员变量d的起始地址 注意内存对齐(以最大的8字节进行对齐)，这里为0x18
    auto d = ((size_t) & ((foo *)0)->d); // 转换为十进制24
    printf("%ld\n", op(struct foo, d));
    return 0;
}
```

### 1.9 C++右值引用

[C++11---右值引用(深度讲解)\_c++11 右值引用-CSDN 博客](https://blog.csdn.net/2303_78660611/article/details/137061857)

- 非 const 右值引用不可以指向一个 const 修饰的常量
- 右值引用不可以直接绑定到一个左值，但可以绑定到使用 move 转换为右值的左值
- 可以对一个右值引用取地址
- 右值引用可以实现移动语义避免拷贝
- 右值引用可以直接绑定另外一个右值引用
- 右值引用可以延续右值(临时值)的生命周期

# 二、数据结构与算法

# 三、嵌入式相关

### 3.1 ARM 架构中的相关寄存器

[ARM 的 37 个寄存器详解-CSDN 博客](https://blog.csdn.net/qq_28816873/article/details/104045425)
[ARM 寄存器及功能介绍/R0-R15 寄存器-CSDN 博客](https://blog.csdn.net/Z_H_Z_0/article/details/106574292)
[4. ARMv8 寄存器 — Armv8/armv9 架构入门指南 v1.0 documentation](https://armv8-doc.readthedocs.io/en/latest/04.html#aarch64)

**R0-R3** **_用作传入函数参数，传出函数返回值_**。在子程序调用之间，可以将 r0-r3 用于任何用途。被调用函数在返回之前不必恢复 r0-r3。如果调用函数需要再次使用 r0-r3 的内容，则它必须保留这些内容。  
**R4-R11** **被用来存放函数的局部变量**。如果被调用函数使用了这些寄存器，它在返回之前必须恢复这些寄存器的值。  
**R12** **是内部调用暂时寄存器 ip**。它在过程链接胶合代码（例如，交互操作胶合代码）中用于此角色。  
在过程调用之间，可以将它用于任何用途。被调用函数在返回之前不必恢复 r12。  
**R13** **是栈指针 sp**。它不能用于任何其它用途。sp 中存放的值在退出被调用函数时必须与进入时的值相同。  
**R14** **是链接寄存器 lr**。如果您保存了返回地址，则可以在调用之间将 r14 用于其它用途，程序返回时要恢复  
**R15** **是程序计数器 PC**。PC 指向哪里，CPU 就会执行对应的指令

---

- 程序计数器（Program Counter，PC）：用于存储下一条指令的地址。
- 累加器（Accumulator，ACC）：用于暂存数据或计算结果。
- 堆栈指针（Stack Pointer，SP）：用于指示堆栈的顶部。
- 基址寄存器（Base Pointer，BP）：通常用于函数调用时的局部变量和参数的存储。
- 通用寄存器（General Purpose Registers，GPRs）：包括 r0-r15，用于暂存数据和地址。
- 状态寄存器（Status Register，SR）或条件码寄存器（Condition Code Register，CCR）：用于存储计算后的状态信息。

### 3.2 I2C 和 UART

见[嵌入式 I2C、SPI、UART 和 USB 通信协议](../知识学习/嵌入式/嵌入式I2C、SPI、UART和USB通信协议.md)

- 当 i2c 的 scI 线是高电平时，主设备会根据 sda 线状态进行总线仲裁
- i2c 的 scI 线不可以被从设备控制，由主设备控制
- uart 波特率存在误差时连续传输的数据越多累积的误差越大
- uart 软件流控会对可传输的 payload 造成约束，防止通信错误导致无效数据传输

### 3.3 优先级继承策略是通过什么方法解决的 RTOS 任务优先级翻转问题

[RTOS---优先级翻转与优先级继承 - M&D - 博客园](https://www.cnblogs.com/mickey-double/p/14366803.html)

原理是让低优先级线程在获得同步资源的时候(如果有高优先级的线程也需要使用该同步资源时)，**临时提升**其优先级。以前其能更快的执行并释放同步资源。释放同步资源后再恢复其原来的优先级

### 3.4 RTOS 相关

- 在 RTOS 任务优先级设置时，一般情况下，越重要的任务应该给越高的优先级
- 空闲任务主要是为了确保调度器启动后，至少有一个任务可以运行
- RTOS 在某些场景中不如裸机系统(没有操作系统)高效
- RTOS 中任务切换需要保存和恢复任务，会产生时间和资源开销，频繁的任务切换可能会影响系统性能
- RTOS 中断函数中的局部变量和被切换任务的局部变量保存在不同栈中
- git pull 命令相当于先执行 git fetch 再执行 git merge
- 在 ARMV8 体系结构里，共有四个异常等级 EL0-EL3，每个异常等级都有一个 SPSR(备份程序状态青存器)用来在发生异常时保存 PSTATE(程序状态寄存器)的值
- 立即数寻址方式不能用于目的操作数字段

### 3.5 常用查分信号的通信总线

CAN 和 RS485

CAN 通讯中，接收单元向具有相同 ID 的发送单元请求数，使用的是遥控帧
