# 一、数据结构与算法

### 1. 哈希表出现哈希冲突解决办法

- [哈希表（一）：解决 hash 冲突的几种方法 - chenjx_ucs - 博客园](https://www.cnblogs.com/scu-cjx/p/8604384.html)
- [哈希表（二）：几种常见的哈希函数（散列函数）构造方法 - chenjx_ucs - 博客园](https://www.cnblogs.com/scu-cjx/p/8609796.html)
- [解决哈希冲突（四种方法）](https://blog.csdn.net/qq_48241564/article/details/118613312)

##### 1.1 哈希函数与哈希冲突

- 常见哈希函数构造方法

  - 直接定址法：取关键字或关键字某个线性函数值作为哈希地址
  - 除留余数法：取关键字被某个不大于哈希表长度的数求余得到的结果作为哈希地址
  - 平方取中法：取关键字平方后根据可使用空间大小选取平方数的中间几位为哈希表地址

- 哈希冲突

  哈希冲突指不同键通过哈希计算后得到相同的哈希值的情况，产生原因是哈希空间有限和哈希计算函数的不均匀(简单来说，就是哈希计算后得到的地址已被其他元素占用)

##### 1.2 哈希冲突解决办法

哈希冲突解决办法分为：开放定址法、再哈希法和链地址法
（1）开放定址法

- 线性探测法
  - 哈希冲突时，将从冲突地址往后遍历哈希表直到空闲位置
  - 探测序列为：$$h(x,i) = (Hash(x) + i) mod\ m$$(Hash(x)为原始哈希函数，i 为探测次数，m 为哈希表大小)
- 平方探测法(二次探测) - 哈希冲突时，将从冲突地址前后按照平方的方式宣召哈希表直到空闲为止 - 探测序列为：$$h(x,i) = (Hash(x) \pm i^2) mod\ m$$(Hash(x)为原始哈希函数，i 为探测次数，m 为哈希表大小)
  （2）再哈希法

同时构造多个不同的哈希函数，发生哈希冲突时就使用第二个、第三个等其他的哈希函数计算地址，直到不发生冲突为止

（3）链地址法

将所有哈希地址相同的键都链接到对应的同一链表里

（4）建立公共溢出区

将哈希表分为基本表和溢出表，发生哈希冲突时的键都存放到溢出表中

### 2. 排好序后的序列进行二分查找不成功至少需要进行对比的次数

[二分查找最大比较次数证明](https://blog.csdn.net/lq1990717/article/details/122646115)

- 对 n 个元素的序列进行二分查找，最小比较次数为 1
- 对 n 个元素的序列进行二分查找，最大比较次数为$\left \lfloor log_2 n \right \rfloor + 1$

### 3. 后缀表达式(逆波兰表达式)

[前缀表达式、中缀表达式和后缀表达式 - 乘月归 - 博客园](https://www.cnblogs.com/zzliu/p/10801113.html)
[C++：前缀、中缀、后缀表达式互相转换详解](https://blog.csdn.net/AngelDg/article/details/104526308)
[前缀、中缀、后缀表达式(逆波兰表达式) - chensongxian - 博客园](https://www.cnblogs.com/chensongxian/p/7059802.html)
[22 张图带你深入剖析前缀、中缀、后缀表达式以及表达式求值](https://segmentfault.com/a/1190000042198655)
[前缀、中缀、后缀表达式转换详解-CSDN 博客](https://blog.csdn.net/walkerkalr/article/details/22798365)

##### 3.1 中缀表达式转换为后缀表达式

- 从左到右遍历中缀表达式
- 遇到操作数，直接加入到后缀表达式当中
- 遇到界限符：遇到`(`直接入栈，遇到`)`则依次弹出栈内运算符并加入后缀表达式，直到弹出`(`为止，注意：`(`不加入后缀表达式
- 遇到运算符。依次弹出栈中优先级**高于或等于**当前运算符的所有运算符，并加入后缀表达式，若碰到`(`或栈空则停止。之后再把当前运算符入栈(**注意：若栈中运算符优先级等于当前运算符优先级，手动计算时也可以选择不弹出，最后得到的后缀表达式会不一致，但计算得到的结果一致**)

##### 3.2 中缀表达式转换为前缀表达式

- 从右往左遍历中缀表达式
- 遇见操作数直接输出
- 遇见运算符：
  – 若该运算符比栈顶运算符的优先级高，则直接入栈  
   – 若该运算符比栈顶运算符的优先级低，则弹出栈顶运算符，直到该运算符的优先级高于栈顶运算符时，将该运算符入栈
- 遇见括号(左右括号不会输出)：
  – 若是右括号，则直接入栈
  – 若是左括号，将栈顶元素弹出
- 当从右往左扫描完表达式后，若栈中仍有运算符，则将这些运算符依次弹出，添加到输出队列的尾端
- 最后将输出队列反转，就得到了前缀表达式

### 4.在一长度为 N 的有序数列中寻找两个数，使得两数之和等于某指定值的最快的算法的平均时间复杂度是？

在长度为 N 的**有序数列**中寻找两个数，使得两数之和等于某指定值，最快的算法通常采用双指针技术（Two Pointers Technique）。这种方法的时间复杂度是 $O(N)$

双指针算法的基本思想是：

1. 将数列分为两个部分，一个指针从左端开始，另一个指针从右端开始。
2. 计算两个指针所指元素的和。
3. 如果这个和等于指定值，那么找到了一对解。
4. 如果这个和小于指定值，说明左侧的值太小，需要增加，所以将左指针向右移动一位。
5. 如果这个和大于指定值，说明右侧的值太大，需要减小，所以将右指针向左移动一位。
6. 重复步骤 2 到 5，直到找到一对符合条件的数，或者两个指针相遇。

这种方法只需要遍历一次数列，因此平均时间复杂度是线性的$O(N)$。在最坏的情况下，如果需要找到所有满足条件的数对，时间复杂度也是 $O(N)$，因为每次移动指针都至少会改变一个元素的值，所以不会重复访问同一个元素

值得注意的是，如果数列中存在重复元素，可能需要额外的逻辑来处理这种情况，以避免重复计算相同的数对。但这不会影响算法的平均时间复杂度

### 5.康威生命游戏

[【4K 动画讲解】【康威生命游戏】用最简介的规则展现最复杂的过程，在固定的规则中创造更多可能\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV11d4y1M7xA/?p=1&vd_source=306f4736c1d442055b9fb0141a07c927)

### 6.组合问题、动态规划问题

$$
C(n,k)=\frac{n!}{k!(n-k)!}
$$

动态规划算法：
[算法之动态规划总结（11 种 DP 类型，70 道全部搞懂）\_dp 算法-CSDN 博客](https://blog.csdn.net/pl0321/article/details/115507286)
