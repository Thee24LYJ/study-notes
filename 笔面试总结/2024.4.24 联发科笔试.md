> 注：这里主要是总结笔试过程中遇到的不熟悉的知识点题目，仅为考试结束后的回忆思考，不一定与原题相同

# 一、计算机基础

### 1.CPU 大小端问题

- 如下数组，其 CPU 采用小端存储模式，问其内存排列位置

```cpp
short int a[12] = {0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99};
int *pa = (int *)&a[0];
pa++;
printf("0x%.8x\n", *pa);
```

![](https://s2.loli.net/2024/04/24/DwaLeVZWxrFdXlS.png)

> sizeof(short int) = 2;
> sizeof(int) = 4;
> 从上图可以看出，pa 最后指向 a+4 即从 33 开始的数据，因此 pa 指向地址的数据存储是 0x33004400，但当对其进行读取时按照小端模式变为 0x00440033

##### 大小端模式

- 大端模式：即高位字节放在内存的低地址端，低位字节放在内存的高地址端。(低对高，高对低)

- 小端模式：即低位字节放在内存的低地址端，高位字节放在内存的高地址端。(低对低，高对高)

大端小端是不同的字节顺序存储方式，统称为**字节序**

![](https://s2.loli.net/2024/04/24/N7BypFitJDY9xLK.png)

- 两种字节序存在意义(各有优点)
  - 大端模式：基于其存储特点，符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小（CPU 做数值运算时从内存中依顺序依次从低位地址到高位地址取数据进行运算，大端就会最先拿到数据的(高字节的)符号位）
  - 小端模式：基于其存储特点，内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容（比如，把 int(4 字节)强制转换成 short(2 字节)，就可以直接把 int 数据存储的前两个字节给 short 就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑；另外 CPU 做数值运算时从内存中依顺序依次从低位地址到高位地址取数据进行运算，开始只管取值，最后刷新最高位地址的符号位就行，这样的运算方式会更高效一些）
- 常见的 CPU 如 PowerPC、IBM 是大端模式，x86 是小端模式。ARM 既可以工作在大端模式，也可以工作在小端模式，一般 ARM 都默认是小端模式。一般通讯协议都采用的是大端模式
- 注意：大端和小端描述的是字节之间的关系，而 MSB(最高有效位)、LSB(最低有效位)描述的是 Bit 位之间的关系

##### 大小端模式判断代码

[CPU 存储方式：大小端判断的三种方法-CSDN 博客](https://blog.csdn.net/m0_48836226/article/details/106946984)

```cpp
// 移位操作判断
void judge_endian1()
{
    unsigned int n = 1;
    cout << (n >> 1 ? "big endian" : "little endian") << endl;
    // cout << (n & 0xf0 ? "big endian" : "little endian") << endl;
}

// 联合体判断
void judge_endian2()
{
    union endian
    {
        char a;
        int b;
    }e;
    e.b = 0x12345678;
    if(e.a == 0x78)
    {
        cout << "little endian" << endl;
    }
    else
    {
        cout << "big endian" << endl;
    }
}

// 强制类型转换判断
void judge_endian3()
{
    int n = 0x12345678;
    char *p = (char *)&n;
    if(*p == 0x78)
    {
        cout << "little endian" << endl;
    }
    else
    {
        cout << "big endian" << endl;
    }
}
```

### 2.计算机寻址偏移问题

- 假设使用相对寻址方式，转移指令占两个字节，分别为操作码和相对位移量。取指令时，每当 cpu 从内存取出一个字节，pc 会自动加 1。当执行到某转移指令时 PC 的内容为 200BH，该指令的转移目标地址为 1EF0H，那此转移指令相对位移量是多少？

> - cpu 从内存中取出转移指令后，pc = pc + 2(两个字节)即为 200DH
> - 相对寻址地址(PC)+相对位移=有效地址，则相对偏移量为 1EF0H - 200DH = 11D(最高位为符号位)，转化为补码为 A2H。
> - 从 200DH 转移到 1EF0H 即(1EF0H - 200DH = -11D)，-11D 用补码表示为 1111 1110 1110 0011，16 进制是 FEE3H

原码：第一位表示符号位, 其余位表示值
反码：正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反
补码：正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1 (**即在反码的基础上加1**)

参考：
[原码, 反码, 补码 详解 - ziqiu.zhang - 博客园](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)
[设相对寻址的转移指令占两个字节，第一字节是操作码，第二字节是相对位移量（用补码表示），若 CPU 每当从存储器取出一个字节时，即自动完成(PC)+1 一 PC-CSDN 博客](https://blog.csdn.net/weixin_45229936/article/details/112755712)

# 二、进程与线程

### 1.求多个进程并发运行时，不发生死锁时的最少共享资源数

求解方法：M 个进程 ，每个进程要 N 个资源，不发生死锁时至少需要资源数的计算公式：$M \times(N－1)+ 1$

参考：
[求多个进程并发运行时，不发生死锁时的最少共享资源数\_不发生死锁的最少资源数公式-CSDN 博客](https://blog.csdn.net/tu_wer/article/details/120969996)

# 三、C、C++基础

### 1.自增运算符

> 注意：++x 在当前语句执行前自增，而 x++在当前语句执行后自增

```cpp
int x=0,y=0;
printf("x=%d,y=%d\n",++x,y++);
// 输出
// x=1,y=0;
```

### 1.strlen()函数

strlen()函数计算传入字符串的长度，但不包含'\0'

参考：
[\[嵌入式 er 笔记\]大端小端详解(含代码及详细注释) - 知乎](https://zhuanlan.zhihu.com/p/144718837)

# 四、算法

### 1.快速排序算法

参考：
[1.6 快速排序 | 菜鸟教程](https://www.runoob.com/w3cnote/quick-sort-2.html)

# 五、思维考察

### 1.找规律

- 求 -1,6,25,62 数列后面一个数：123
