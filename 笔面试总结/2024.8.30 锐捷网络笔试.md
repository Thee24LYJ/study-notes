# 1.使用广度优先搜索算法(BFS)遍历一个无向图，BFS 算法最坏情况下的时间复杂度为$O(V+E)$，空间复杂度为$O(V)$

[广度优先搜索（BFS）算法-CSDN 博客](https://blog.csdn.net/beenles/article/details/130729968)
[BFS（图论） - OI Wiki](https://oi-wiki.org/graph/bfs/)

最坏情况下，需要访问所有顶点和边才能完成遍历，因此此时时间复杂度为$O(V+E)$
BFS 算法使用队列数据结构来存储待访问的顶点和邻居顶点，因此空间复杂度取决于队列中存储的元素数量。在最坏情况下，即当图为完全二叉树时，BFS 算法需要存储的元素数量达到$O(V)$级别，因此空间复杂度也是$O(V)$

# 2.设有三个作业 J1,J2,J3,其运行时间分别是 2h,3h,4h,假定它们同时到达，并在同一台处理器上以单道方式运行，则平均周转时间最小的执行顺序是 J1->J2->J3

[操作系统：周转时间和其他时间-CSDN 博客](https://blog.csdn.net/qq_42192693/article/details/103012606)

周转时间：程序从提交给系统到作业完成的时间间隔
评价周转时间：周转时间/作业数量

J1 从最开始到达至服务完成时间为 2h，然后 J2 从最开始到达至服务完成时间为 2+3=5h，最后 J3 从最开始到达至服务完成时间为 2+3+4=9h，因此周转时间为 2+5+9=16h，平均周转时间为 16/3=5.3h

# 3.外部排序

[7.数据结构 外部排序(External Sort)](https://zhuanlan.zhihu.com/p/582162747)
[数据结构之外部排序：归并排序法-CSDN 博客](https://blog.csdn.net/qq_41587740/article/details/104382587)

# 4.字典树

[字典树 (Trie) - OI Wiki](https://oi-wiki.org/string/trie/)
[【数据结构】字典树 TrieTree 图文详解-CSDN 博客](https://blog.csdn.net/qq_49688477/article/details/118879270)

- 字典树，用于统计、排序和保存大量字符串，查找时间复杂度为$O(log_2n)$
- 字典树的主要思想是利用字符串的公共前缀节约存储空间
- 对字典树进行查找时，看从 root 节点触发是否按照顺序对应该字符串且结尾的字符节点为终点

# 5.某主存容量为 50MB,初始时刻 T0 全部分区空闲，采用 Best Fit 算法分配和释放内存，从初始到 T1 时刻，分配释放顺序为：分配 12MB,分配 23MB,释放 12MB,分配 9MB,分配 11MB,此时主存最大空闲分区大小是 4MB

详见[动态分区分配算法](../知识学习/数据结构与算法/动态分区分配算法.md)

# 6.假设系统中有 7 个同类资源，进程 P1、P2 和 P3 需要的资源数分别为 6、5 和 2。现在 P1、P2 和 P3 已申请到的资源数分别为 3、2 和 1，则执行安全性检测算法的结果是：无法找到一个安全序列使得所有进程都能执行完毕并释放资源，系统处于不安全状态

[假设系统中有 7 个同类资源,进程  P1、P2&nbs\_牛客网](https://www.nowcoder.com/questionTerminal/f9fdf0f788214bd09e1ff2a10e8243ed?)

P1、P2 和 P3 已申请资源数为 6，剩下资源数为 1，此时只能把该资源那个 P3，P3 执行完毕释放后剩下资源数为 2，再拿给 P1 或 P2 都无法满足其需求，发生死锁现象

# 7.图的相关知识点

[数据结构——图中结点、边和度之间的关系总结-CSDN 博客](https://blog.csdn.net/weixin_46072314/article/details/115031849)
[（看了包会）连通子图、连通分量、极大连通子图、极小连通子图-CSDN 博客](https://blog.csdn.net/Mmyine/article/details/105066677)
[数据结构\_图-CSDN 博客](https://blog.csdn.net/light_2025/article/details/130217724)

- 有向完全图的顶点与边数的关系：$E=v(v-1)$
- 线性表可以是空表，树可以是空树，但图不可以是空图

# 8.页面置换算法

[一分钟学会页面置换算法【OPT、FIFO、LRU、NUR】-CSDN 博客](https://blog.csdn.net/qq_42257666/article/details/105125865)
[页面置换算法（按照步骤来讲的，超级详细）-CSDN 博客](https://blog.csdn.net/qq_43992949/article/details/110401080)

### 最佳置换算法（OPT)

选择的被淘汰页面，将是以后永不使用的，或许是在最长(未来)时间内不再被访问的页面；采用最佳置换算法可保证获得最低的缺页率。但是由于无法预知哪一个页面是未来最长时间内不再被访问的，因而该算法是无法实现的

### 先进先出算法(FIFO)

淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰

### 最近最久未使用算法(LRU)

根据页面调入内存后的使用情况进行决策，选择最近最久未使用的页面予以淘汰

### CLCOK 算法/最近未使用算法(NUR)

每页设置一个访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列；当某个页面被访问时，其访问位置 1。淘汰时，检查其访问位，如果是 0，就换出；若为 1，则重新将它置 0；再按 FIFO 算法检查下一个页面，到队列中的最后一个页面时，若其访问位仍为 1，则再返回到队首再去检查第一个页面

# 9.出栈序列个数

[【数据结构与算法/组合数学】出栈序列的个数问题详解-CSDN 博客](https://blog.csdn.net/qaqwqaqwq/article/details/123522307)

给定一个入栈序列，求所有可能的出栈序列数($C_n$为卡特兰数，$C_{2n}^{n}$为组合)：

$$
C_n = \frac{1}{n+1}C_{2n}^{n}
$$

$$
C_n^m = \frac{A_n^m}{m!} = \frac{n!}{m!(n-m)!}
$$

# 10.根据树的中序和前序或后续遍历求另外一种遍历

[二叉树的前（先）序中序和后序遍历 以及如何通过两个序列确定唯一二叉树-CSDN 博客](https://blog.csdn.net/qunqunstyle99/article/details/87906199)

### 前序遍历

遍历顺序为`根节点->左子树->右子树`

### 中序遍历

遍历顺序为`左子树->根节点->右子树`

### 后序遍历

遍历顺序为`左子树->右子树->根节点`

给出中序遍历，再给出前序遍历或后序遍历，则可以唯一确定一棵二叉树(前提是**给出中序遍历**)

- 前序遍历第一个出现的是该树的根节点，后序遍历最后一个是根节点
- 在中序遍历中，根节点左方的是左子树，右方的是右子树

比如说：给定前序遍历`ABCDEGF`和中序遍历`CBEGDFA`

- 从前序遍历可知根节点为 A
- 那么结合根节点为 A 和中序遍历可知：这棵树只存在左子树(因为中序遍历结尾为根节点)
- 那么 B 是 A 的左节点，因为左子树遍历序列 BCDEGF 也是按照前序遍历的
- B 在中序遍历中左边只有 C，因此 B 的左子树只有 C 节点
- 又由前序遍历可知 D 是 B 的右节点，将 ABC 从中序遍历中去掉变为 EGDF，此时 D 右子树只有 F，D 左子树包含 E 和 G
- 根据前序遍历和中序遍历 E 和 G 顺序都为 EG，因此 E 是 D 的左节点，G 是 E 的右节点

# 11.其他

- 树的度数：树中节点中最大的叶子数，因此二叉树的度不一定为 2
- 系统中有四个进程，阻塞队列中最多有四个进程
- 缓冲技术可以缓解处理机与外部设备速度的矛盾
- TCP 和 UDP 首部都有校验和和目的端口号
